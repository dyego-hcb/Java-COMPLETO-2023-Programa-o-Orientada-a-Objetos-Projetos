-- RESUMO SEÇÃO 25 - INTERFACE GRAFICA COM JAVA FX - DO CURSO JAVA COMPLETO 2023 PROGRAMAÇÃO ORIENTADA A OBJETOS + PROJETOS --

JAVAFX -> BILBIOTECA DE CRIACAO DE INTERFACES JAVA

VISAO GERAL DO JAVAFX:
- JAFAFX(TECNOLOGIA PADRAO ORACLE AFIRMOU QUE JFX E O FUTURO) E O SUCESSO DO SWIN E JAVA AWT(ABTRACT WINDOWS TOOLKIT) PARA INTERFACES GRAFICAS COM JAVA
- JAVAFX PODE SER USADO PARA DESKTOP WEB E MOBILE
- UMA TELA JAVA FX PODE SER MONTADA VIA CODIGO JAVA(INSTANCIAR OBJETOS) OU VIA CODIGO FXML(VARIACAO DO XML, TIPO HTML PARA WEB)
- COM O LANCAMENTO DO JAVA 11, JAVAFX NAO E MAIS PARTE DO JDK
* O JAVAFX PRECISA SER BAIXADO E CONFIGURADO SEPARADAMENTE
* E MANTIDO PELA GLUON
- JAVAFX E PROJETADO SOBRE O PADRAO MVC
* MODEL -> CONSISTE NOS DADOS DE DOMINIO E TODA A LOGICA DE TRNASFORMACAO DESSES DADOS
* VIEWS -> SAO AS TELAS DE INTERACAO COM O USUARIO(GUI)
* CONTROLLERS -> SAO AS CLASSES RESPONSAVEIS POR TRATAR AS INTERACOES DO USUARIO COM AS VIEWS (MANIPULACOES DE EVENTOS DE INTERACOES COM AS TELAS)

(            VIW JAVA FX                 )                  (          MODEL          )
|    (           STAGE                 ) |                  |   (ENTITIES) (ENTITIES) |
|    |   (       SCENE               ) | |                                ^V
|    |   |     (   NODE            ) | | |                  (           CONTROLLER       )
|    |   |     |  (NODE)  (NODE)   | | | |  <----------->   | EVENTHANDLE1, EVENTHANDLEN | 

PADRAO MVC DEIXA O SISTEMA MAIS ORGANIZADO E MAIS FACIL DE SE ENTENDER, POIS DELEGA TODA A RESPONSIBILIDADES A ENTIDADES RESPOSNAVEIS
JAVAFX IMPLEMENTA METAFORA, ONDE TEMOS A TELA UM PALCO E AS CENAS, PODENDO TROCAR AS CENAS, DENTRO DAS CENAS TEMOS OS NODOS(NOS) SAO OS ELEMENTOS DEFINIDOS NO ARQUIVO FXML

PARA UTILZIAR A BIBLIOTECA JAVAFX, DEVEMO INSTALAR ALGUMAS FERRAMENTAS A MAIS NO ECPLISE, TAIS QUAIS SAO:

1- SCENE BUILDER -> E UTILIZADO PARA FAZER DESENHO DAS TELAS GRAFICAS, O SEU CODIFO CONTE E DESENVOLVIMDO E MANTIDO PELO OPENFX, MAS O INSTALADOR E DISPONIBILIZADO PELA GLOUN
2- PREPARACAO DO ECLIPSE -> PARA PREPARA O ECLIPSE DEVEMOS FAZER ALGUMAS ACOES TAIS QUAIS SAO:
- DEVEMOS BAIXAR O JAVA FX SDK NO SITE DA GLOUN POIS E ELA QUE MANTEM AS BUILDS OFICIAS DO JAVA FX, PARA ISSO TEM UM MACETE PARA BAIXAR VERSOES ANTERIORES, BASTA PEGAR A VERSAO ATUAL, COPIAR ENDERECO DO LINK DO BOTAO DE DOWNLOAD E SUBSTITUIR PELA VERSAO QUE DESEJA
- APOS FEITO ISSO, DEVEMOS INSTALAR O PLUGIN E(FX)CLIPSE(ATENCAO VESAO 3.4.1 OU SUPERIOR), PARA ISSO DEVMOS FZE O SEGUINTE:
- HELP -> INSTALL NEW SOFTWAR
- WORK WHITH:
* LINK DIRETO: : http://download.eclipse.org/efxclipse/updates-released/3.4.1/site/
- LOCALIZE E(FX)CLIPSE
- NEXT NEXT ETC
- REINICIAR O ECPLISE
- REFERENCIAR O SCNEBUILDER NO ECLIPSE:
- WINDOW->PREFERENCES->JAVAFX
- ENTRAR O CAOMINHO COMPLETO DO ARQUIVO EXECUTAVEL DO SCENE BUILDER
- CIRAR UMA USER LIBERY NO ECPLISE COM O NOME JAVAFX:
- WINDOWS -> PREFERENCES -> JAVA -> BUILDPATH -> USERS LIBARES -> NEW
- DE O NOME DE USER LIBERE
- ADD EXTERNAL JARS(APONTE PARA A PASTA BIN DO JAVA FX)

PARA CRIAR UM PROJETO JAVAFX NO ECLPISE DEVEMOS SEGUIR ALGUNS PASSO A PASSO QUE SERAO LISTADOS NO CHECKLIST ABAIXO:

CHECKLIST:
- CRIACAO DO PROJETO:
* FILE -> NEW -> OTHER -> JAVAFX PROJECT
* DE UM NOME AO PROJETO E CLIQUE NEXT
* NA ABA LIBRARIES, SELECIONE MODULEPATH, CILQUE ADD LIBARY E SELECIONE JAVAFX
* CLICK FINISH
* MODULE INFO: DONT'T CREATE

- CONFIG DO BUILD:
* BOTAO DIREITO NO PROJETO -> RUN AS -> RUN AS CONFIGURATIONS -> ARGUMENTS -> VM ARGUMENTS
* COPIAR O CONTEUDO A FRENTE ADAPTANDO PARA SUA PASTA: --module-path "caminho_lib_jdk_baixada" --add-modules=javafx.fxml,javafx.controls

AO CRIAR UM PROJETO JAVAFX NO ECPLISE, UM ARQUIVO APPLICATION.CSS E GERADO AUTOMATICAMENTE, O MESMO SERA USADO APENAS SE O PROGRAMADOR OPTAR POR UTILIZAR CSS PARA ESTILIZAR OS ELEMENTOS DA TELA
APOS FEITO ISSO, PODEMOS NOTAR QUE TEMOS UM ARQUIVO MAIN, ONDE ESSE ARQUIVO MAIN CONTEM OS COMANDOS BASICOS PARA UMA APLICACAO JAVAFX, PARA SER UMA APLICACAO JAVAFX ESSA CLASSE TEM QUE EXTENDE DE APPLICATION, ESSA CLASSE POSSUI UM METODO ABSTRATO QUE E O START, ONDE SOMOS OBRIGADOS A IMPLMENTAR, NAO SO APENAS O METODO START, MAS OUTROS METODOSS INIT(COISAS QUE DEVEM ACONTECER ANTES DA APP INICIAR) E STOP(COISA QUE QUER Q ACONTECE DEPOIS QUE ENCERRAR), POREM APENAS O STAR E OBRIGADO A IMPLMENTAR
NESSE EXEMPLO, TEMOS A CRIACAO DE UM PAINEL, DEPOIS UMA TELA, E UM PALCO QUE VEM DE PARAMETRO DO START
.SHWO MOSTRA O CONTEUDO DO PALCO
SEMPRE TEM QUE ESTAR VERIRICANDO SE CAPTURA ALGUMA EXECAO
PARA EXECUTAR, TEMOS A MAIN PADRAO DO JAVA, ONDE CHAMAMOS COM O LAUNCH QUE UM METOTO ESTTICO DA APPLICATION QUE SERVE PARA INICAR O JAVA FX

POREM AINDA FALTO UMA PEQUENA CONFIGURACAO PARA RODA DE FATO UMA APLICACAO JAVA FX, DEVEMOS CONFIGURA A BUILD, INFORMANDO QUE E PRA PEGAR OS MODOULOS JAVAFX SDK DA BILBIOTECA BAIXADA EXTERNAS, OS COMANDOS ADD-MODULES ADICIONA TODOS OS MODULOS JUNTAMENTE COM JAVAFX.CONTROLS, CITADA NO TOPICO CONFIG DA BUILD

PARA ENCERRAR A APP, BASATA CLICKAR NO X OU ENTAO BOTAO DIREITO NO CONSOLE E TERMINATE ALL

TESTANDO O FXML: E A LINGUAGEM DE MARCACAO PARA DESENHAR A TELA, INCLUSIVE USANDO O SCENE BUILD, E TIPO UM HTML

CHECK LIST:
- CRIAR UM PACOTE GUI
- CRIAR UM FXML NO PROJETO: BOTAO DIREITO NO PACOTE GUI -> NEW -> OTHER -> NEW FXML DOCUMENT
* DEFINIR UM NOME
- ABRE O FXML NO SCENEBUILDER: BOTAO DIREITO -> OPEN IN SCENEBUILDER
- OBSERVE AS GYUAS LIBERY, DOCUMENT E INSPETOR
* INSPECTOR -> LAYOUT DEFINE LARGURA E ALTURA DEPOIS SALVE
* LIBARY -> CONTROL ACRESCENTE ALGUNS CONTROLES EX TEXFIELD, BUTTON, ETC

APOS FEITO ISSO, DEVE-SE REZER O METODO START PARA EXIBIR A TELA CRIADA

OBS1: A UTILIZACAO DO PACOTE GUI E PARA ADOTAR AS BOAS PRATICAS DE PROGRAMACAO

NO ARQUIVO FXML, TEMOS:

NA PRIMEIRA LINHA UM CABECALHO XML (SIMILAR AO HTML)
A IMPORTACAO DA CLASSE ACHORPANE, QUE E UM OBJETO DE NODE, ELE DEFINE UM PAINEL ONDE PODEMOS DEFINIR OBJETOS QUE PODEM ESTAR ANCORADOR A DETERMINADAS POSICOES
FALA DE ONDE PEGA A SINTAXE DO DOCUMENTO
DENTRO DO ACHORPANE DEFINE OS ELEMENTOS

NO SCENEBUILDER TEMOS 3 ABAS PRINCIPAIS QUE SAO:

1- LIBARY -> ONDE CONSEGUIMOS ENCONTRAR TODOS OS COMPONENTES PARA COMPOR UMA TELA, COMO COMPONENTES, PAINEIS, BOTOES, ETC.
2- DOCUMENT -> E A ABA QUE CONTERA A HIERAQUIA DOS NODES(ELEMENTOS) DA SUA TELA, COMO ANCHORPANE
3- INPECTOR -> ONDE TEREMOS AS ABAS LAYOUT(PARAMETROS PARA CONFIGURAR O LAYOUT DO ELEMENTO) CODE E PROPRIETES (PROPRIEDADES)

OBS1: DEVE-SE SELECIONAR O ANCHORPANE
OBS2: AO DEFINIR AS MUDANCAS, BASTA APERTA A TECLA TAB PARA VER O DESENHO DA TELA
OBS3: PARA EDITAR BASTA DAR DUPLO CLICKE
OBS4: AO SALVAR NO SCNEBUILDER, O MESMO ESCREVE NO ARQUIVO FXML NO ECPLISE OS ELEMENTOS ADICIONADOS E CONFIGURACOES DA TELA

PARA CARREGAR ESSA TELA CRIADA NA NOSSA APLICACAO JAVA, DEVEMOS REALIZAR ALGUMAS MUDANCAS, COMO:

EM VEZ DE CRIAR UM PAINEL VAZIO, IREMOS FAZER A MESMA CARREGAR O ARQUIVO FXML CRIADO, ATRAVES DO COMANDO DE UMA INSTANCIACAO DE UM PARENT PARENT PARENT FXMLLOADER.LOAD(GETCLASS().GETRESOURCE("/GUI/NOME.FXML"))

O OBJETO DO TIPO PARENT E UMA SUPER CLASSE DO ANCHORPANE 
O PARENT E UMA CLASSE MAIS GENERICA DENTRE O GRUPO DE OBJETOS QUE COMPOE AS TELAS

TRATANDO EVENTOS COM JAVAFX:

ESSE ASSUNTO E A BASE DE QUALQUER TRABALHO COM INTERFACE GRAFICA, POIS UTILIZAMOS OS CONTROLADORES PARA DETERMINAR O QUE OCORRER QUANDO DETERMINADA ACAO ACONTECER, ESSAS ACOES SERAO FEITAS PELO USUARIOS COM INTERACOES NA TELA

CHECK LIST:
- CRIE UMA CLASSE CONTRTOLADORA DA SUA VIEW 
- NO CONTROLADOR:
* CRIAR UM ATRIBUTO CORRESPONDENTE AO CONTROLE DESEJADO E ANOTAL0 COMO @FXML
* CRIAR UM METODO PARA TRATAR O EVENTO DESEJADO DO CONTROLE E ANOTALO COMO @FXML

- NA VIEW(SCNE BUILDER):
* ASSOCIAR A VIEW AO CONTROLLER (ABA CONTROLER E NA PRIMEIRA CAIXINHA DE TESTO DIGITAR O NOME DO PACOTE.NOME DA CLASSE)
* SELECIONE O CONTROLE E ASSOCIE A ELE O ID (ABA CODE, FX:ID E SELECIONA O ATRIBUTO CRIADO NA CLASSE CONTROLLER)
* SELECIONE O CONTROLE E ASSOCIE O METODO AO EVENTO DESEJADO (ABA CODE, DEPENDE DA ACAO DO BOTAO SELECIONA A QUE FOR IDEAL)

DICA: QUANDO MUDAR ALGO NO SCNEBUILDE, USAR PROJECT->CLEAN NO ECLIPSE PARA FORCAR A ATUALIZACAO DO PROJETO PARA EVITAR BUGS

MOSTRANDO ALERT:

ALERT E UMA JANELA DE AVISO QUE APARECE NA FRENTE DA JANELA PRINCIPAL, PARA ISSO PRECISAMOS INSTANCAIR UM OBJETO DO TIPO ALERT E SETAR ALGUMAS CONFIGURACOES, COMO O TITULO, CABECALHO, CONTEUDO E SUA VISIBILIADE, TUDO ISSO EM UMA FUNCAO
O ALERT POSSUI DIVERSOS TIPOS DE ALERTAS, COMO DE WARNING, INFORMATION, SUCESS, ERROR, ETC.

USANDO TEXTFIELD E LABEL (APP PARA CALCULAR SOMA):

CHECKLIST:
- DESENHAR TELA NO SCENEBUILDER(USAR UM LABEL PARA MOSTRAR O RESULTADO)
* PROPRIEDADE PROMPTTEXT
- CRIAR UM CONTROLLER E IMPLEMENTAR CODIGO PARA MOSTRAR A SOMA
* TRATAR EXECAO NUMBERFORMATEXCEPTION
- DE VOLTA AO SCENEBUILDER, FAZER AS ASSOCIACOES DE ID E EVENTO

DICA: QUANDO MUDAR ALGO NO SCNEBUILDE, USAR PROJECT->CLEAN NO ECLIPSE PARA FORCAR A ATUALIZACAO DO PROJETO PARA EVITAR BUGS

OBS1: AO DEFINIR O NOME DOS ATRIBUTOS NA CLASSE CONTROLLER, SEMPRE COLOCAR QUAL O COMPONENTE QUE ESTA SENDO UTILIZADO, VISANDO BOAS PRATICAS DE PROGRAMACAO
OBS2: PODEMOS ALTERAR O CONTEUDO DE UMA LABEL UTILIZANDO O METODO SET TEXT
OBS3: PODEMOS UTILIZAR ALTERTS PARA MOSTRAR O ERRO DE EXECOES CAPTURADAS

LIMITACOES PARA TEXTFIELD E INITIALIZABLE:

LIMITACOES -> ACEITAR APENAS DIGITO, ACEITAR APENAS NUMEROS FLUTUANTES, ETC
COLOCAR ALGUM CODIGO PARA EXECUTAR NA INICIALIZACAO DO CONTROLADOR

CHECK LIST:
- CRIAR CLASSE UTILITARIO CONSTRAINTS
- FAZER O CONTROLADOR IMPLMENTAR A INTERFACE INITIALIZABLE

A CLASSE CONSTRAINTS VAI TER ALGUNS METODOS PADROES PARA ADICIONAR LISTENER NOS CONTROLES E ESSE LISTENER VAI CONTROLAR O COMPORTAMENTO DO CONTROLE
O LISTENER E UMA FUNCAO PARA EXECUTAR QUANDO O CONTROLE SOFRE MODIFICACAO OU INTERACAO COM O USUARIO, BASTA UTILIZAR A FUNCAO PROPETY DO TIPO DO CONTROLE E TAMBEM A FUNCAO ADDLISTENER, ONDE IREMOS PASSAR UMA FUNCAO QUE QUEREMOS QUE EXECUTA QUANDO O CONTROLE SOFRE ALGUMA ALTERACAO
GERALMENTE A FUNCAO QUE E PASSADA POR PARAMETRO E UMA EXPRESSAO, ONDE IREMOS TER 3 ARGUMENTOS 1 OBSERVABLE QUE VAI SER UMA REF PARA O CONTROLE, O VALOR ANTIGO, O VALOR NOVO
DEVE-SE VERIRICAR SE O NOVO VALOR NAO E NULO E SE ELE ATENDE A UMA EXPRESSAO REGULAR UTILIZANDO O METODO MATCHES("\\d*") EXEMPLO DE INTEIRO 

COMBOBOX:

COMBO BOX E AQUELA LISTINHA QUE PODEMOS ESCOLHER OS ELEMENTOS

CHECKLIST:
- PROPRIEDADE PROMPT TEXT
- USAR TIPO GENERICO, POR EXEMPLO: COMBOBOX<PERSON>
- OBSERVABLELIST<PERSON>, OBSERVABLESET<PERSON>, OBSERVABLEMAP<PERSON>
* PARA CRIAR UM OBSERVABLELIST: FXCOLLECTIONS.OBSERVABLELIST(LIST)
- COMBOBOX.SETITEMS(OBSERVABLELIST)
- NOTA: O COMBO BOX, POR PADRAO, MOSTRA O TOSTRING DO OBJETO
- PARA OBTER O ELEMENTO SELECIONADO: COMOBOX.GETSELECTIONMODEL().GETSELECTEDITEM() -> RETORNA UM ELEMENTO SELECIONADO DO COMBO BOX
- PARA ACESSAR A COLECAO: COMOBOBOX.GETITENS() -> RETORNA TODOS OS ELEMENTOS DA LISTA DO COMBO BOX
- PARA DEFINIR O QUE MOSTRAR NA COMBOBOX, DEVEMOS DEFINIR UMA EXPRESSAO LAMBIDA, E IMPLEMENTAR O METODO UPDATEITEM

PARA DEFINIR UM EVENTO, SEMELHANTE AO BOTAO, VAI DEPENDER DO QUE VOCE QUER FAZER QUANDO OCORRER UM EVENTO.

VISAO GERAL DOS PRINCIPAIS CONTAINERS DE LAYOUT:

CONTAINERS -> SAO COMPONENTE ESPECIAIS NOS QUAIS VOCE ACOMODA OUTROS COMPONENTES, SERVE PARA ORGANIZAR A TELA
OBS1: NA ABA LIBERY DO SCNEBUILDER HA UMA ABA CHAMADA CONTAINERS, QUE VAO TER OS COMPONENETES ESPECIAIS PARA MONTAR O LAYOUT DA NOSSA TELA

CHECKLIST:
- ANCHORPANE -> PAINEL ONDE PODEMOS ANCORAR OS ELEMENTEOS, PODEMOS ALTERAR A POSICAO DO COMPONENTE QUE ESTA NO ANCORPANE ATRAVES DO LAYOUT NO INSPECTOR E PODEMOS ANCORAR A DETERMINADAS POSICOES FIXAS
- GRIDPANE -> UM CONTANIER NA FORMA DE GRADE, ONDE PODEMOS COLOCAR COMPONENTES DENTRO DA MATRIZ DO GRIDPANE, MUITO UTILIZADO EM FORMS
- SPLITEPANE -> E UMA TELA DIVIDIA EM 2 PARTES, TEMOS TANTA A VERSAO VERTICAL E HORIZONTAL
- VBOX E HBOX -> MUITO USADO PELA SIMPLICIDADE E PELO COMPORTAMENTO PREVISIVEL, O QUER FOR COLOCANDO VAI SER ACOMODANDO UM EM BAIXO DO OUTRO
- BPRDERPANE -> NAO POSSUI UM COMPORTAMENTO SIMPLES IGUAL O VBOX, O BORDER PANE POSSUI O LAYOUT EM PARTES, TOP, LEFT, CENTER, RIGTH, BOTTOM, PARA INSERIR OS ELEMENTOS ONDE DESEJA, BASTA APENAS ARRASTAR PARA A POSICAO CITADA ACIMA, O QUE COLOCAR NO CENTRO E NAO COLOCAR NADA EM ESQUERDA E DIREITA, O DO CENTRO EXPANDE E PEGA TUDO
- SCROLLPANE -> APARECER O SCROL PARA DESCER QUANDO POSSUI MUITAS INFORMACOES

OBS1: PODEMOS COLOCAR UM CONTAINER DENTRO DE UM OUTRO, COMO POR EXEMPLO COLOCAR UM GRID PANE DENTRO DE UM ANCHORPANE

PROJETO JAVAFX COM JDBC:

NESSA ETAPA IREMOS DESENVOLVER UM PROJETO JAVAFX COM JDBC, O MESMO ESTA DISPONIVEL NO REPOSITORIO DO GITHUB NO SEGUINTE LINK ABAIXO: 

https://github.com/zebodexx/workshop-javafx-jdbc

ABAIXO, IREMOS DESCREVER O PASSO A PASSO DE DESENVOLVIMENTO DESSE PROJETO, DESTACANDO ALGUNS PONTOS IMPORTANTES PARA BOAS PRATICAS DURANTE O DESENVOLVIMENTO.

PASSO 1: INICIALIZACAO DO PROJETO -> NESSE PASSO IREMOS CRIAR O REPOSITORIO NO GIT E CRIAR O PROJETO JAVA FX NA MAQUINA LOCAL E ASSOCIALO AO REPOSITORIO GIT

PASSO 2: TELA MAIN VIEW -> NESSA ETAPA IREMOS CRIAR A TELA PRINCIPAL DO PROJETO

CHECKLIST:
- CREATE FXML MAINVIEW IN PACKAGE GUI
- LOAD FXML IN MAIN
- UPDATE MAIN

PASSO 3: MAIN VIEW DESING -> NESSA ETAPA IREMOS ESTILIZAR A MAIN VIEW NO SCENEBUILDER

CHECK LIST:
- DESING MAINVIEW
- CUSTOMIZE MANU ITEMS
- UPDATE MAIN

OBS1: PARA DEIXAR O SCROLLPANE AJUSTADO A JANELA USAMOS O SETFTITOHEIGTH TRUE E WIDTH TRUE TAMBEM.

PASSO 4: MAIN VIEW CONTROLLER -> NESSA ETAPA IREMOS CRIAR A CLASSE MAIN VIEW CONTROLLER, PARA QUE SEJA POSSIVEL A INTERACAO DO USUARIO COM A TELA

CHECKLIST:
- CREATE CONTROLLER
- IN VIEW ASSOCIATE CONTROLLER, IDS, EVENTS

PASSO 5: ABOUT VIEW -> CRIACAO DA TELA DE ABOUT, QUANDO O BOTAO DE ABOUT FOR CLICKADO REDIRECIONAIR NESSA PAGINA

CHECKLIST:
- INCLUDE UTIL CLASSES TO THE PROJECT(ALERTS, CONSTRAINTS)
- CREATE ABOUT.FXML(VBOX)
- IN MAIN, EXPOSE MAINSCNE REFERENCE
- IN MAINVIEWCONTROLLER, CREATE LOADVIEW METHOD

OBS1: PADDING E O ESPACAMENTO EM RELACAO AS BORDAS

PARA MOSTRAR A VIEW DENTRO DA TELA PRINCIPAL, DEVEMOS PEGAR UMA REFERENCIA DA CENA, A MESMA FOI DECLARADA NA MAIN, POREM A MESMA E SO VISTA NA MAIN, COM ISSO DEVEMOS EXPORT UMA REF PARA ESSA CENA, CRIADNO UM OBJETO STATICO PRIVADO, PARA PEGAR A CENA, DEVEMOS CRIAR UM METODO GET PARA RETORNAR A CENA.
PRECISAMOS DESSA REFERENCIA POIS COMO ESTAMOS MANIPULANDO NA TELA PRINCIPAL, DEVEMOS PEGAR A REFERENCIA DOS OBJETOS DA TELA PRINCIPAL E ALTERAR SUA VISUALIZACAO A DETERMINADA ACAO DO USUARIO, ACRESCENTANDO OS NOS FILHOS DA TELA EXTERNA NA QUAL DESEJA MOSTRAR.
PODEMOS PEGAR A REF ATRAVES CO COMANDO GETCONTENT
APOS PEGAR O CONTEUDO DE UM CONTAINER, DEVEMOS PEGAR OS NO FILHOS DO CONTAINER, UTILIZANDO O COMANDO GETCHILDERN

OBS1: PARA MANIPULAR AS VBOX E HBOX DEVEMOS UTILIZAR A FUNCAO GETCHILDERN
OBS2: PARA GARANTIR QUE TODO O PROCESSAMENTO DE UMA FUNCAO OCORRA SEM SER INTERROMPIDO DEVEMOS COLOCAR O SYNCHRONIZED NA FUNCAO ANTES DO TIPO DE RETORNO

PASSO 6: DEPARTMENTLIST VIEW DESING -> NESSA ETAPA IREMOS CRIAR A DEPARTMENTLIST VIEW

COMO VAMOS REALIZAR UM CRUD DE DEPARTMENT, IREMOS CRIAR UMA TELA QUE IRA LISTAR TODOS OS DEPARTAMENTOS QUE ESTAO CADASTRADOS

CHECKLIST:

- CREATE DEPARTMENTLIST.FXML (VBOX)
- IN MAINVIEWCONTROLLER, LOAD DEPARTMENTLIST

PASSO 7: DEPARTAMENTLIST CONTROLLER -> COMO TEMOS ALGUNS BOTOES DE INTERACOES COM O USUARIO, DEVEMOS CRIAR A CLASSE CONTROLLER DAQUELA VIEW

CHECKLIST:
- CREATE MODEL.ENTITIES.DEPARTAMENT 
- CREATE DEPARTAMENTLISTCONTROLLER
- IN VIEW, ASSOCIATE CONTROLLERS, IDS, EVENTS

OBS1: AO CRIAR UM TABLE VIEW PRECISAMOS ESPECIFICAR O TIPO DE OBJETO DAQUELA TABLE VIEW
OBS2: PARA CRIAR UM TABLE COLUMN, PRECISAMOS DE 2 TIPOS DE ENTIDADE A PRIMEIRA E TIPO DA ENTIDADE, E O OUTRO E TIPO DA COLUMA

O SIMPLES FATO DE INSTANCIAR UMA TABELA E COLUNAS NAO SIGNIFICA QUE VAI FUNCIONAR, CASO NAO FUNCIONE, UMA SOLUCAO E CRIAR UM METODO AUXILIAR INICIALIZENODES PARA INICIAR APROPRIADAMENTE O COMPORTAMENTE DAS COLUNAS DA TABELA COM O SEGUINTE COMANDO NOME_COLUNA.SETCELLVALUEFACTORY(NEW PROPERTYVALUEFACTORE<>("NOME_ATRIBUTO_CLASSE"));
O COMANDO ACIMA CITADO E UM PADRAO DO JAVA FX PARA ELE INICIAR O COMPORTAMENTO DAS COLUNAS

OBS1: PARA QUE A TABLEVIEW ACOMPANHE A LARGURA E ALTURA DA JANELA, DEVEMO FAZE NOVAMENTE A REF DO STAGE ATUAL, UTILIZANDO O METODO (STAGE) GETMAINSECET().GETWINDOW() QUE RETORNA A REFERENCIA DA JANELA, PARA ATRIBUIR PARA UM STAGE NOTE O DOWNCAST, APOSFEITO ISSO, BASTA UTILIZAR O NOME_DA_VIEW.PREFHEIGHTPROPERTY().BIND(NOME_STAGE.HEIGTHPROPERTY())

PASSO 8: DEPARTAMENT SERVICE -> NESSA ETAPA IREMOS INICIAR O DESENVOLVIMENTO DA CLASSE DEPARTAMENT SERVICE QUE E UMA CLASSE QUE SERA RESPONSAVEL POR PRESTAR ALGUNS SERVICOS RELACIONADOS A DEPARTAMENTO

CHECKLIST:
- CREATE MODEL.SERVICES.DEPARTAMENTSERVICE WITH FINDALL METHOD
- IN DEPARTAMENTLISTCONTROLLER:
* CREATE DEPARTAMENTSERVICE DEPENDECI WITH SET METHOD
* CREATE OBSERVABLELIST<DEPARTAMENT>
* CREATE UPDATETABLEVIEWDATA METHOD

COMO NAO TEMOS UM MECANISMO DE INJECAO DE DEPDENECIA, ONDE A MESMA E MANUAL, CASO O PROGRAMADOR NAO TRATE ALGUMA EXECAO, QUE PRECISA SER TRATADA, UTILIZAMOS A EXECAO ILLEGALSTATEEXCEPTION

PODEMOS PEGAR O CONTROLLER DE UMA VIEW ATRAVES DO LOADER.GETCONTROLLER

PASSO 9: INITIALIZING ACTION AS PARAMETER -> NESSA ETAPA IREMOS 

ACAO DE INICIALIZACAO POR PARAMENTRO -> E PARA NAO TER CODIGO DUPLICADO, COMO TIVEMOS NO PASSO ANTERIORO COM O LOADVIEW2, PASSANDO UMA FUNCAO COMO PARAMETRO
PODEMOS FAZE ISSO DA SEGUINTE MANEIRA:

PODEMOS NO MOMENTO EM QUE CHAMAMOS A FUNCAO, PASSAR OS DADOS DE INICIALIZACAO POR PARAMETRO COMO VISTO ABAIXO:

NOME_FUNC(PARAMETRO_1, (PAREMETRO DA FUNCAO)->{ CONTEUDO DA FUNCAO})

FEITO ISSO, DEVEMOS IR NA FUNCAO NO QUAL VAI RECEBER A EXPRESSAO LAMBIDA COMO PARAMETRO E COLOCAR AS SEGUINTES ALTERACOES:

<T> NOME_FUNC(TIPO_PARAMETRO1 NOME_PARAMETRO_1, CONSUMER<T> NOME_ATT_FUNC)

APOS FEITO ISSO, DEVEMOS UTILIZAR A SEGUINTE ATRIBUICAO:

T NOME_ATRIBUTO = LOADER.GETCONTROLLER
NOME_ATT_FUNC.ACEPT(NOME_ATRIBUTO)

CHECKLIST:
- ADD A CONSUMER<T> PARAMETERS TO LOADVIEW METHOD 
- AFTER LOADGIN VIEW, CALL ACCEPT FROM THE CONSUMER
- ADD CONSUMER, INSTANCE ON LOADVIEW CALLS

PASSO 10: ADDING DATABASE ACCESS -> FAZER LIGACAO COM O BD E A APP

CHECKLIST:
- ADD MODEL.ENTITIES.SELLER
- ADD DB.PROPERTIES DO PROJECT
- ADD DATA ACESS PACKAGES TO PROJECT:
* DB
* MODEL.DAO
* MODEL.DAO.IMPL
- IN DEPARTAMENTSERVICE, ADD DEPARTAMENTDAO DEPENDECY WITH FACTOREY CALL 

OBS1: E IMPORTANTE ORGANIZAR O PROJETO EM CAMADAS POIS PODEMOS REAPROVEITAR CODIGOS

PASSO 11: DEPARTAMENTFORM (DIALOG) DESING -> CRIAR A TELA DE FORMULARIO PARA CADASTRAR NOVO DEPARTAMENTO

DIALOG, ABRE EM CIMA DA JANELA PRINCIPL COM COMPORTAMENTO MODAL, OU SEJA, NAO DA PRA MECHE NA TELA ANTERIOR

CHECKLIST:
- CREATE GUI.UTIL.UITILS WITH CURRENTSTAGE METHOD -> POIS PRECISAMOS DO STAGE ATUAL PARA ABRIR O DIALOG EM CIMA
- CREATE DEPARTAMENTFORM.XML(ARCHOR PANE)
* GRIDPANE 3X3 (ANCHORS 20 TOP 20LEFTX)
* ID TEXT BOX: NOT EDITABLE
* LABEL: ERROR RED
* HBOX(SPACING 5)
- IN DEPARTAMENTLISTCONTROLLER CREATE DIALOGFORM METHOD -> UTILIZA-SE A CHAMADA DO METODO INITOWNER PARA DEFINIR EM QUAL JANELA O DIALOG IRA APARECER E PARA DEFINIR UM COMPORTAMENTO USAMOS O INITMODALITY
- CALL CREATEDIALOGFORM ON NEW BUTTON ACTION

PARA PEGARMOS A TELA DE UM DETEMINADO STAGE UTILIZAMOS A SEGUINTE SINTAXE: (Stage) ((Node) event.getSource()).getScene().getWindow();
ONDE FAREMOS UM DOWNCASTING PARA NODE E DEPOIS PARA STAGE

PASSO 12: DEPARTMENTFORMCONTROLER -> NESSA ETAPA IREMOS CONFIGURAR O CONTROLLER DA VIEW DEPARTMENTFORMCONTROLER

CHECKLIST:
- CREATE DEPARTAMENTFORMCONTROLLER
- IN VIEW, ASSOCIATE CONTROLLERS, ID, EVENTS

PASSO 13: PASSING DEPARTMENT OBJECT TO DEPARTMENT FORM VIEW -> PASSAR UM OBJETO DEPARTAMENTO PARA O FORM, POIS O FORM SERVE PARA INSERIR E ATUALIZAR ALGUM OBJETO, ENTAO, DEVEMOS INSTANCIAR UM OBJETO PARA POPULAR AS CAIXAS DE TEXTO DO FORM

CHECKLIST:
- IN DEPARTAMENTFORMCONTROLLER
* CREATE DEPARTAMENT DEPENDECY WITH SET METHOD
* CREATE UPDATEFORMDATA METHOD
- IN DEPARTAMENTLISTCONTROLLER
* UPDATE ONBTNNEWACTION METHOD
* UPDATE CREATEDIALOGFORM METHOD

OBS1: PARA CONVERTER STRING DA CAIXINHA DO INPUT TEXT PARA INTEIRO, UTILIZAMOS A FUNCAO STRING.VALUEOF

PASSO 14: SAVING A NEW DEPARTAMENT -> NESSA ETAPA IREMOS SALVAR UM DEPARTAMENTO, COLETANDO OS DADOS DO FORM E SALVANDO NO OBJETO INSTANCIADO NO PASSO ANTERIOR

CHECKLIST:
- IN UTILS, IMPLEMENTS TRYPARSETOINT METHOD -> AJUDARA CONVERTER STRING PARA INTEIRO
- IN DEPARTAMENTSERVICE, CREATE SAVEORUPDATE METHOD
- IN DEPARTAMENTFORMCONTROLLER
* CREATE A DEPARTAMENTSERVICE DEPENDENCY WITH SET METHOD
* IMPLEMENTS ONBTSAVEACTION
* IMPLEMENT ONBTCANCELACTION
- IN DEPARTMENTLISTCONTROLLER, INJECT DEPARTAMENTSERVICE INSTANCE

OBS1: QUANDO ESTAMOS UTILIZANDO INJECAO MANUAL, DEVEMOS TRABALHAR COM PROGRAMACAO DEFENSIVA 

PASSO 15: OBSERVER DESING PATTERN TO UPDATE TABLEVIEW -> NESSA ETAPA, IREMOS DESENVOLVER UM PADRAO DE PROJETO OBSERVER, QUE IRA NOTIFICAR MUDANCAS NO CASO DE MUDANCAS

CHECKLIST:
- CREATE INTERFACE GUI.LISTENERS.DATACHANGELISTENER
- IN DEPARTMENTFORMCONTROLER (SUBJECT CLASSE QUE EMITE O EVENTO)
* CREATE LIST <DATACHANGELISTENER> DEPENDECY WITH SUBSCRIBRE METHOD
* NOTIFY SUBSCRIBERS EHNE NEEDED
- IN DEPARTMENTLIST (OBSERVER CLASSE QUE RECEBE O EVENTO)
* IMPLEMENT DATACHANGELISTENER INTERFACE 
* SUBSCRIBRE FOR DEPARTAMENTFORMCONTROLLER

OBS1: O PADRAO DE PROJETO OBSERVER E MUITO UTILIZADO PARA COMUNICAR 2 OBJETOS DE FORMA DESACOBLADA, POIS QUEM EMITE O EVENTO NAO CONHECE QUEM RECEBE

PASSO 16: VALIDATION EXCEPTION -> NESSA ETAPA IREMOS IMPLEMENTAR UMA VALIDACAO DE DADOS E CRIAR UMA EXECAO PERSONALIZADA CASO OS DADOS NAO ESTEJAM VALIDOS

CHECKLIST:
- CREATE MODEL.EXCEPTION.VALIDATIONEXCEPTION
- IN DEPARTMENTFORMCONTROLLER
* IN GETFORMDATA METHOD, IMPLEMENT VERIFICATIONS AND THROW VALIDATIONEXCEPTION
* IMPLEMENT SETERRORMESSAGES METHOD
* IN ONBTSAVEACTION, CATCH VALIDATIONEXCEPTION

OBS1: O METODO TRIM TIRA OS ESPACOS

PASSO 17: UPDATE DEPARTAMENT -> NESSA ETAPA, IREMO IMPLEMENTAR A ACAO DE ATUALIZAR DEPARTAMENTOS, ADICIONANDO BOTOES PARA EDICAO EM CADA UM DOS DEPARTAMENTOS LISTADOS

CHECKLIST:
- IN DEPARTAMENTLISTCONTROLLER
* CREATE NEW ATTRIBUTE: TABLECOLUMN<DEPARTAMENT, DEPARTAMENT> TABLECOLUMNEDIT
* CREATE INITEDITBUTTONS METHOD
* IN UPDATETABLEVIEWDATA, CALL INITEDITBUTTONS
- IN DEPARTMENTLIST.FXML 
* INCLUDE NEW TABLE COLUMN
* ASSOCIATE ID

PASSO 18: REMOVE DEPARTMANET -> NESSA ETAPA, IREMOS IMPLEMENTAR A ACAO DE REMOVE DEPARTAMENTOS

CHECKLIST:
- IN ALERTS, CREATE SHOWCONFIRMATION METHOD
- IN DEPARTMENTSERVICE, CREATE REMOVE METHOD
- IN DEPARTAMENTLISTCONTROLLER
* CREATE NEW ATRIBUTE: TABLECOLUMN<DEPARTAMENT, DEPARTAMENT> TABLECOLUMNREMOVE
* CREATE INITREMOVEBUTTONS METHOD (CATCH DBINTREGRITY EXCEPTION)
* IN UPDATEVIEWDATA, CALL INITREMOVEBUTTONS
- IN DEPARTAMENTLISTFXML
* INCLUDE NEW TABLECOLUMN
* ASSOCIATE ID

OBS1: O TIPO Optional RETURONA TRUE OR FALSE DEPENDENDO DE QUAL BOTAO O USUARIO CLICKOU

PASSO 19: DELETE .SETINGS FOLDER -> IREMOS EXCLUIR ESSA PASTA PARA EVITAR POSSIVEIS PROBLEMAS DE COMPATIBLIDADE

CHECKLIST:
- .GITIGNORE: .SETTINGS/
- DELETE .SETTINGS/FOLDER

PASSO 20: SELLER LIST -> NESSA ETAPA, IREMOS DESENVOLVER A TELA DE LISTAGENS DE VENDEDOR

CHECKLIST:
- CLONE SELLERSERVICE
* REPLACE DEPARTAMENT -> SELLER
- CLONE SELLERLISTCONTROLLER
* REPLACE DEPARTAMENT -> SELLER
* COMMENT CREATE DIALOGFORM
- CLONE SELLERLISTVIEW
* REPLACE DEPARTMENT-> SELLER
- UPDATE MAINVIEWCONTROLLER.ONMENUITEMSELLERACTION

PASSO 21: SELLER TABLEVIEW -> NESSA ETAPA, IREMOS ADICIONAR O TABLE VIEW NA VIEW SELLER

CHECKLIST:
- GUI.UTILS.UTIL
* FORMATTABLECOLUMNDATE METHOD
* FORMATTABLECOLUMNDOUBLE METHOD
- SELLERLISTCONTROLLER
* TABLECOLUMN ATRIBUTES (EMAIL, BIRTHDATE, BASESALARY)
* UPDATE INITIALIZENODES
- SELERLISTVIEW
* TALBECOLUMN (EMAI, BIRTHDATE, BASESALARY)
* ASSOCIATE FX:ID

PASSO 22: SELER FORM -> NESSA ETAPA, IRMEOS CRIA A TELA DE FORMULARIO SIMPLES DE VENDEDOR

CHECKLIST:
- CLONE SELLERFORMCONTROLLER
* REPLACE DEPARTMENT -> SELLER
- CLONE SLLERFORM VIEW
* REPLACE DEPARTMENT -> SELLER
- SELLERLISTCONTROLLER
* UNCOMMENT CREATEDIALOGFORM

PASSO 23: TEXFIELD E DATAPICKER -> CONSTRUCAO DO FORMULARIO DO CADASTRO DE VENDEDOR

CHECKLIST:
- GUI.UTIL.UTILS
* FORMATDATEPICKER METHOD
- TEXFIELD E DATAPICKER ATTRIBUTES (EMAIL, BIRTHDATE, BASESALARY)
- LABEL ERROR ATRIBUTES (EMAIL, BIRTHDATE, BASESALARY)
- EDIT SELLERFORMVIEW
- BUGFIX: SELLERDAOJDBC.INSTANTIATESELLER (OBJ.SETBIRTHDATE(NEW JAVA.UTIL.DATE(RS.TIMESTAMP("BIRTHDATE).GETTIME())))
- UPDATE: INITAILZE NODES
- UPDATE: UPDATEFORMDATA

PASSO 24: DEPARTAMENT COMBOBOX -> NESSA ETAPA, VAMOS COLOCAR UMA COMBO BOX PARA SELECIONAR QUAL DEPARTAMENTO AQUELE VENDEDOR PERTENCE

CHECKLIST:
- UPDATE CONTROLLER
* DEPARTMENTSERVICE DEPENDECY (ATTRIBUTE AND SET METHOD)
* COMBOBOX<DEPARTAMENT> COMBOMBOXDEPARTMENT
* OBSERVABLELIST<DEPARTAMENT> OBSLIST
* INITIALIZECOMBOBOXDEPARTMENT
* UPDATEFORMDATA
- UPDATE VIEW
* COMOBO BOX
* FX ID

PASSO 25: SAVING SELLER -> IREMOS AGORA DESENVOLVER NESSA ETAPA A FUNCIONALIDADE DE INSERIR NOVOS VENDEDORES E ATUALIZAR TAMBEM

CHECKLIST:
- UPDATE GETFORMDATA
- UPDATE: SETERRORMESSAGES

PASSO 26: BUILDING JAR FILE -> CONSTRUIR O ARQUIVO EMPACOTADO

CHECKLIST:
- BUILD JAR FILE 
* RIGHT CLICK PROJECT NAME -> EXPORT -> JAVA/RUNNABLE JAR FILE -> NEXT
* SELECT MAIN CLASS
* SELECT DESTINATION FOLDER
* LIBIRTY HANDLING: 3DR OPTION
- PACK FILES
* JAR FILE
* DB.PROPERTIES
* MYSQLCONNECTOR
* JAVAFX SDK
* JAVA SDK

ALEM DO ARQUIVO JAR JERADO, PARA RODAR NA APLICACAO DO CLIENTE, DEVE-SE LEVAR TAMBEM OS ARQUIVOS LISTADOS NO PACK FILES

PASSO 27: INSTALATION -> NESSA ETAPA IREMOS VER COMO INSTALAR A APLICACAO NA MAQUINA DO CLIENTE

CHECKLIST:
- INSTALL JAVA (SETUP JAVA_HOME)
- COPY JAVAFX (SETUP PATH_TO_FX) AND PLACE MYSQLCONNECTOR IN LIB FOLDER
- COPY JAR E DB.PROPERTIES

RUN APP:
JAVA --MODULE %PATH_TO_FX% --ADD-MODULES JAVAFX.CONTROLS, JAVAFX.FXML -CP MYQPP.JAR APLLICATION.MAIN

BAT FILE(OPTIONAL) -> BASTA CRIAR UM ARQUIVO .BAT E COLAR O CODIGO ABAIXO E CLICKAR NO MESMO QUE IRA EXECUTAR O CODIGO ABAIXO, FAZENDO COM QUE NAO SEJA NECESSARIO DIGITAR O CODIGO TODA HORA
JAVA --MODULE %PATH_TO_FX% --ADD-MODULES JAVAFX.CONTROLS, JAVAFX.FXML -CP MYQPP.JAR APLLICATION.MAIN

Windows Shortcut (optional) -> COMO CRIAR UM ATALHO NO WINDOWS PARA A APP, FAZENDO COM QUE FIQUE COM O ICONE DO JAVA E NAO .BAT
Target:
"C:\Program Files\Java\jdk-17.0.3\bin\java.exe" --module-path %PATH_TO_FX% --add-modules
javafx.controls,javafx.fxml -cp myapp.jar application.Main
Start in:
C:\appfolder