-- RESUMO SEÇÃO 18 - INTERFACES - DO CURSO JAVA COMPLETO 2023 PROGRAMAÇÃO ORIENTADA A OBJETOS + PROJETOS --

TOPICO MUITO IMPORTANTE, POIS COM INTERFACES CONSEGUIMOS CONSTRUIR SOLUCOES FLEXIVEIS E ELEGANTES, NESSA PARTE ESTAMOS ENTRANDO NA PARTE INTERMEDIARIA-AVANCADA
IREMOS RESOLVER UM PROBLEMA SEM INTERFACE E DEPOIS COM INTERFACE E DISCUTINDO AS VANTAGENS EM RELACAO A SOLUCAO

INTERFACES:

AVISOS:
- A PARTIR DO JAVA 8, INTERFACES PODEM TER "DEFAULT METHODS" OU "DEFENDER METHODS" E METODOS STATICOS
- ISSO POSSUI IMPLICACOES CONCEITUAS E PRATICAS, QUE SERAO DISCUTIDAS MAIS A FRENTE NESSA SECAO
- PRIMEIRO IREMOS TRABALHAR COM A DEFINICAO "CLASSICA" DE INTERFACES, ONDE NA DEFINICAO CLASSICA NAO TEMOS A IMPLEMENTACAO DE METODOS, SO QUE A PARTIR DO JAVA 8 PODEM TER, DEPOIS IREMOS ACRESCENTAR O CONCEITO DE DEFAULT METHODS.

A INTERFACE E UM TIPO QUE DEFINE UM CONJUNTO DE OPERACOES QUE UMA CLASSE DEVE IMPLEMENTAR.
A INTERFACE ESTABELECE UM CONTRATO QUE A CLASSE DEVE CUMPRIR -> CONTRATO POIS DEVE CUMPRIR O CONTRATO DE IMPLEMENTAR OS METODOS QUE SAO DEFINIDOS NA CRIACAO DA INTERFACE
INTERFACES SERVEM PARA CRIAR SISTEMAS COM BAIXO ACOPLAMENTO E FLEXIVEIS

SINTACE DE UMA INTERFACE EM JAVA:

interface NomeInterface 
{
    tipo_retoro_method nome_method();
}

OBS1: INTERFACE SIMPLESMENTE DEFINE AS OPERACOES, E COMO SE FOSSE EM GROSSO MODO, UMA CLASSE ABSTRATA QUE POSSUI APENAS METHODOS ABSTRATOS

TOPICO IMPORTANTE SOBRE ESTRUTURACAO DAS PASTA NO CAPITULO DE COMPOSICAO!!

1- VIEWS
2- CONTROLLERS
3- ENTITIES
4- SERVICES
5- REPOSITORES

OBS1: CADA UM PODE SER UM TIPO DE OBJETOS

NO CASO DO EXERCICIO PROPOSTO, IREMOS UTILIZAR AS SEGUINTE ESTRUTURACAO DE PASTA

1- MODEL.ENTITIES -> REPRESENTANDO TODAS AS ENTIDADES DO NOSSO EXERCICIO
2- APPLICATION -> ONDE ESTA A CLASSE PROGRAM COM A MAIN PARA EXECUTAR O PROGRAMA
3- MODEL.SERVICES -> ONDE ESTARA A LOGICA DO PROGRAMA PARA REALIZAR ALGUNS SERVICOS, COMO NO CASO DO EXEMPLO, CACLCULAR AS TAXAS

OBS1: E BOM UTILIZAR SEMPRE OS GET E NAO O ATRIBUTO DIRETO, POIS PODE SER QUE NO FUTURO AO MUDAR A LOGICA DE UM GET, VOCE NAO PRECISAR FICAR ALTERANDO NO CODIGO ONDE ESTA O VALOR DA VARIAVEL DIRETA
OBS2: CASO QUEIRA OBRIGAR O USUARIO A INFORMAR DADOS SOBRE O OBJETO BASTA CRIAR APENAS 1 CONSTRUTOR COM ARGUMENTOS, ISSO IMPEDE QUE OBJETOS SEJAM CRIADOS SEM ARGUMENTOS
OBS3: AO UTILIZAR O DURATION.BETWEEN PODEMOS CONVERTER O TEMPO PARA MEDIDA QUE QUISERMOS USANDO O TONOME_MEDIDA()
OBS4: MATH.CEILS ARREDONDA PARA CIMA

PROBLEMA DA SOLUCAO 1 SEM INTERFACE:

O PROBLEMA E QUE EXISTE UM ALTO ACLOPAMENTO ENTRE OS SERVICOS RENTALSERVICES E BRAZILTAXSERVICE, POIS NA RENTALSERVICES NOS FAZEMOS UMA DECLARACAO DIRETA DO BRAZILTAXSERVICES, E ISSO NAO E UMA BOA PRATICA POIS, O NOSSO RENTALSERVICES FICA DEPENDENDO EXCLUSIVAMENTE DO BRASILTAXSERVICE, OU SEJA, ELE FUNCIONA APENAS PARA AS REGRAS DE TAXA DO BRASIL, QUANDO TIVERMOS QUE FAZER UMA TROCA, POR EXEMPLO ADICIONAR UMA TAXA PARA UM OUTRO PAIS, TEREMOS QUE FAZER DIVERSAS ALTERACOES, E ISSO PODE SER MUITO CUSTOSO, E OBRIGA A GENTE A CRIAR N CLASSES PARA N TAXAS PARA N PAISES
PARA SOLUCIONAR ESSE, IREMOS ADICIONAR UMA INTERFACE CHAMADA TAXSERVICE, E COMO VIMOS ANTERIORMENTE, NAO SERA NECESSARIO IMPLEMENTAR SEUS METODOS, POIS SAO ESTATICOS, QUE FARA UM CONTRATO COM O BRAZILTAXSERVICE, QUE IRA IMPLEMENTAR E REALIZAR OS CACLULOS NECESSARIOS, CASO QUEIRA TROCAR A TAXA DE UM PAIS, BASTA APENAS TROCAR A CLASSE QUE ESTA RELACIONADA

OBS1: UMA CLASSE QUE IMPLEMENTA A INTERFACE OBRIGATORIAMENTE DEVE-SE IMPLEMENTAR O METODO DA INTERFACE
OBS2: AO REFERENCIARMOS UMA INTERFACE EM ALGUMA CLASSE, PODEMOS INSTANCIAR OBJETOS QUE ESTENDEM A ESSA INTERFACE E PASSAR POR PARAMETRO NO CONSTRUTOR DA CLASSE NO LUGAR DA INSTANCIA DE UMA INTERFACE, FAZENDO COM QUE A CLASSE QUE EXTENDA A INTERFACE SEJA UMA SUBCLASSE DESSA INTERFACE, PODENDO ENTAO REALIZARMOS UPPERCASTING

INVERSAO DE CONTROLE, INJECAO DE DEPENDENCIA:

SOLUCAO 1:
AO REALIZARMOS UMA ASSOCIACAO DIRETA DE UMA CLASSE PARA OUTRA, ACABA QUE GERAMOS UM ACOPLAMENTO FORTE, POIS UMA CLASSE CONHECE A DEPEDENCIA CONCRETA DE OUTRA.
AO GERAR UM ACLOPAMENTO FORTE, IREMOS TER 2 PONTOS DE ALTERACAO, SE A CLASSE CONCRETA MUDAR E PRECISO MUDAR A OUTRA CLASSE TAMBEM.

SOLUCAO 2:
AO REALIZAR UMA ASSOCIACAO DIRETA DE UMA INTERFACE A EM UMA CLASSE, ACABA QUE GERAMOS UM ACLOPAMENTO FRACO, POIS UMA CLASSE NAO CONHECE A SUA DEPENDENCIA CONCRETA.
AO GERAR UM ACLOPLAMENTO FRACO, SE A CLASSE CONCRETA MUDAR, A OUTRA CLASSE NAO MUDA

INJECAO DE DEPENDECIA POR MEIO DE CONSTRUTOR, E QUANDO DELEGAMOS A ALGUMA CLASSE QUE DEVE INSTANCIAR ALGUM OBJETO QUE EXTENDS A INTERFACE, E PASSAR NO CONSTRUTOR DA CLASSE QUE TEM UM OBJETO DO TIPO DA INTERFACE, ISSO DELEGA A OBRIGACAO DE ALGUMA CLASSE QUE IMPLEMENTA A INTERFACE PASSAR POR PARAMETRO PARA O CONSTRUTOR DE UMA DETERMINADA CLASSE QUE POSSUI UMA INTERFACE COMO O ATRIBUTO, FAZENDO COM QUE ASSIM SEJA POSSIVEL ASSOCIAR AQUELE DETERMINADO METODO NAQUELE MOMENTO

OBS1: A NAO INJECAO DE DEPENDECIA E QUANDO NAO RECEBEMOS NO CONSTRUTOR O OBJETO QUE E SUBCLASSE DA INTERFACE, E DEFINE NO MESMO CONSTRUTOR, POREM ISSO GERA UM FORTE ACLOPAMENTO, POIS A PROPRIA CLASSE ESTA SENDO RESPONSAVEL DE INSTANCIAR A SUA DEPENDECIA, CAINDO NOVAMENTE NOS 2 PONTOS DE ALTERACAO

INVERSAO DE CONTROLE -> PADRAO DE DESENVOLVIMENTO QUE CONSISTE EM RETIRAR DA CLASSE A RESPONSABILIDADE DE INSTANCIAR SUAS DEPENDENCIAS
INJECAO DE DEPENDENCIA -> E UMA FORMA DE REALIZAR A INVERSAO DE CONTROLE: UM COMPONENTE EXTERNO INSTANCIA A DEPENDENCIA, QUE E ENTAO INJETADA NO OBJETO "PAI". PODE SER IMPLEMENTADA DE VARIAS FORMAS COMO:
- CONSTRUTOR 
- CLASSE DE INSTANCIACAO(BUILDER/FACTORY)
- CONTAINER/FRAMEWORK

OBS1: INTERFACE SAO UM TIPO DE INSTANCIA GENERIA DE UM DETERMINADO TIPO DE CLASSE QUE EXTEND A INTERFACE 
OBS2: TIPOS LOCALDATE TEM AS FUNCOES PLUS QUE ADICIONA ALGUM VALOR INTEIRO NA DETERMINADA

HERDAR VS CUMPRIR CONTRATO:

QUANDO FALAMOS EM HERANCA E INTERFACE, TEMOS ALGUNS ASPCETOS EM COMUM, QUE SAO:
- RELACAO E-UM -> TAMBEM VALE PARA INTERFACES, POIS UMA INTERFACE E COMO SE FOSSE A CLASSE PAI MAIS GENERICA POSSIVEL 
- GENERALIZACAO/ESPECIALIZACAO -> COMO DITO ANTERIORMENTE, A INTERFACE E UM TIPO GENERICO ASSIM COMO AS CLASSES PAIS EM HERANCAS
- POLIMORFISMO -> MUDANCA DE COMPORTAMENTO PARA CADA TIPO DE OBJETO CONCRETO

DIFERENCA FUNDAMENTAL:
- HERANCA -> REUSO DE INFORMACOES E COMPORTAMENTO, COMO REAPROVEITAMENTO DE ATRIBUTOS E METODOS
- INTERFACE -> CONTRATO A SER CUMPRIDO, POIS QUEM FOR UMA CLASSE CONCRETA QUE IMPLEMENTA A INTERFACE, DEVE TER AQUELES METODOS, APENAS IMPLEMENTAR OS METODOS

OBS1: JAVA 8 > POSSIBILITAM METODOS DEFAULT EM INTERFACES
OBS2: A DEFINICAO CLASSICA DE INTERFACE E DEFINIR UM CONTRATO PARA A IMPLEMENTACAO DAQUELE METODO

E SE EU PRECISAR IMPLEMENTAR UMA INTERFACE, POREM QUERO DEFINIR UMA ESTRUTURA COMUM REUTIILZAVEL PARA TODAS AS FIGURAS?
NAO PODEMOS INSTANCIAR ATRIBUTOS NAS INTERFACES, PORTANTO TERIAMOS QUE IMPLEMENTAR UMA ESTRUTURA REUTILIZAVEL EM TODAS AS CLASSES
POREM HA UM MODO DE SE BURLAR ESSE IMPECILIO, BASTA CRIARMOS UMA CLASSE STATICA E EXTENDE-LA A INTERFACE, E DEPOIS PODEMOS CRIAR A CLASSES CONCRETAS QUE HERDAM DA CLASSE STATICAS QUE IRAO HERDAR OS METODOS DA INTERFACE, COM ISSO E POSSIVEL FAZER O REUSO DE ESTRUTURAS COMUM REUTILIZAVEL UTILIZANDO UMA COMBINACAO DE CLASSES ABSTRATAS E INTERFACES E CLASSES CONCRETAS.

E IMPORTANTE DEFINIR UM CONTRATO COMO INTERFACA POIS PODEMOS TER CLASSES CONCRETAS QUE NAO POSSUEM ALGUNS ATRIBUTOS COMUMS REUTILIZAVEIS MAS SAO OBJETOS DAQUELE TIPO

OBS1: NA INTERFACE NAO E NECESSARIO ESCREVER PUBLIC ABSTRACT ANTES DO METODO POIS JA ESTAMOS DEFININDO COMO ABSTRACT NA INTERFACE
OBS2: CLASSES ABSTRATAS QUE HERDAM DE INTERFACE NAO TEM NECESSIDADE DE IMPLEMENTAR OS METODOS DA INTERFACE
OBS2: SE INSTANCIARMOS UMA VARIAVEL DO TIPO DA INTERFACE QUE E O MAIS GENERICO POSSIVEL, PODE HAVER FALTAS DE ATRIBUTOS NA INTERFACE PARA GERAR AQUELE ATRIBUTO
OBS3: O PROJETO DE SERVICO DE E-MAIL UTILIZANDO SPRING BOOT, TAMBEM UTILIZA ESSE METODO DE UTILIZAR CLASSES ABSTRATAS E INTERFACES

HERANCA MULTIPLA E O PROBLEMA DO DIAMANTE:
PROBLEMA DO DIAMANTE: A HERANCA MULTIPLA PODE GERAR O PROBLEMA DO DIAMANTE, QUE E UMA AMBIGUIDADA CAUSADA PELA EXISTENCIA DO MESMO METODO EM MAIS DE UMA SUPERCLASSR

OBS1: HERANCA MULTIPLA NAO E PERMITIDA NA MAIORIA DAS LINGUAGENS!!
OBS2: EM JAVA NAO E POSSIVEL REALIZAR MAIS DE 1 EXTENDS POR VEZ EM UMA SUBCLASSE, PARA CONTORNAR ESSE IMPECILIO ENCONTRADO DE NAO PODER EXTENDER MAIS DE 1 CLASSE EM UMA SUBCLASSE, PODEMOS UTILIZAR INTERFACES, ONDE TEMOS UMA CLASSE QUE HERDA DA CLASSE PAI, E ESSA CLASSE FILHA PODE TER 2 INTERFACES RELACIONADAS COM ELA, COM ISSO PODEMOS REALIZER COMPORTAMENTOS DIFERENTES 
OBS3: PODEMOS HERDAR APENAS DE 1 CLASSE POR VEZ, MAS PODEMOS HERDAR DE UMA CLASSE E IMPLEMENTAR UMA INTERFACE
OBS4: INTERFACES, PODEMOS IMPLEMENTAR MAIS DE UMA INTERFACE EM UMA CLASSE
OBS5: INTERFACES E OBRIGADO A IMPLEMENTAR TODOS OS METODOS, FAZENDO COM QUE ACABE COM A AMBIGUIDADE
OBS6: INTERFACE E UMA FORMA DE IMPLEMENTA UMA CLASSE QUE PODE REALIZAR MAIS DE UMA INTERFACE
OBS7: ISSO NAO E HERANCA MULTIPLA, POIS NAO HA REUSO NA RELACAO ENTRE UMA CLASSE QUE POSSUI O USO DE 2 INTERFACES, POIS ESSA CLASSE NAO HERDA MAS SIM IMPLEMENTA OS METODOS DA INTERFACE(CUMPRINDO O CONTRATO)
OBS8: DENTRO DA CONCEPCAO CLASSICA NAO TEM REUSO

INTERFACE COMPARABLE -> ELA DEFINE UMA OPERACAO INT COMPARTETO(T, OBJ), O T E COMO SE FOSSE A LISTA, AI VALE O MESMO RACIOCINIO, ONE NESSA INTERFACE E PAREMETRIZADA EM UM TIPO T QUALQUER E ESSE METODO COMPARTETO RECEBE UM OBJETO O DO TIPO T
SINTAXE:
public interface Comparable<T>
{
    int compareTo(T, o);
}

NAO E POSSIVEL UTILIZAR O METODO COLLECTIONS.SORT EM UMA CLASSE SEM O COMPARABLE, POIS NAO E POSSIVEL COMPARAR OBJETOS DE UM TIPO "CRIADO", ENTAO E NECESSARIO IMPLEMENTA A INTERFACE COMPARABLE<> E DENTRO DOS <> PASSA ACLASSE QUE DESEJA FAZER A COMPARACAO E DEVE-SE IMPLEMENTAR O METODO COMPARETO E SUA LOGICA
QUANDO DIZEMOS QUE UMA CLASSE E COMPARAVEL, ASSINAMOS UM CONTRATO PARA IMPLEMENTAR O METODO DE COMPARACAO ENTRE DOIS OBJETOS
AO COMPARAR UM OBJETO COM OUTRO, O COMPARTETO NOS RETORNA UM NUMERO INTEIRO, E ESSE NUMERO PODE SER UM NUMERO INTEIRO POSITIVO QUANDO MAIOR EM ORDEM ALFABETICA, OU UM NUMERO INTEIRO NEGATIVO QUANDO MENOR EM ORDEM ALFABETICA, OU ZERO QUANDO SAO IGUAIS.

OBS1: O METOTDO COLLETCTIONS,SORT ORDENA UMA COLECAO(LISTAS)
OBS2: O SPLIT RETORNA 1 VETOR COM CADA POSICAO A PARTIR DA CONDICAO
OBS3: O METODO COLLECTIONS.SORT NAO FUNCIONA EM UM TIPO DE CLASSE CRIADA NORMAL, SEM IMPLEMENTAR NENHUMA INTERFACE OU OUTRA CLASSE, PARA FUNCIONAR, DEVEMOS DAR O IMPLEMENTS NA INTERFACE COMPARABLE<NOME_CLASSE> E DEVE-SE IMPLEMENTAR O COMPARTETO E DEVE-SE IMPLEMENTAR AS REGRAS

A INTREFACE COMPAREBLE SERVE PARA DEFINIR COMO COMPARAR UM OBJETO COM OUTRO, DEVE-SE DELEGAR A LOGICA DESSA COMPARACAO

DEFAULT METHODS(DEFENDER METHODOS):
- A PARTIR DO JAVA 8, INTERFACES PODEM CONTER METODOS CONCRETOS, VALE RESLTAR TAMBEM QUE PODEM TER METODOS STATICOS E PRIVADOS TAMBEM
- A INTENCAO BASICA E PROMOVER IMPLEMENTACAO PADRAO PARA METODOS DE MOTO A EVITAR:
* REPETICAO DE IMPLMENTACAO EM TODA CLASSE QUE IMPLEMENTE A INTERFACE
* A NECESSIDADE DE SE CRIAR CLASSES ABSTRATAS PARA PROVER REUSO DA IMPLEMENTACAO
- OUTRAS VANTAGENS:
* MANTER A RETROCOMPATIBILIDADE COM SISTEMAS EXISTENTES -> BIBLIOTECAS CONTINUAM COMPATIVEL, POIS METODOS PADRAO VEM COM A PALAVRA DEFAULT PARA DIFERENCIALO
* PERMITIR QUE "INTERFACES FUNCIONAIS"(QUE DEVEM CONTER APENAS UM METODO) POSSAM PROVER OUTRAS OPERACOES PADRAO REUTILIZAVEIS

OBS1: PARA DEFINIRMOS UM TIPO DEFAULT, BASTA ESCREVERMOS DEFAULT ANTES DO TIPO DO RETORNO DAQUELE METODO, APOS FEITO ISSO, PODEMOS IMPLEMNETAR QUAIS SAO OS METODOS PADROES/GENERICO DAQUELA INTERFACE VISANDO ELIMINAR REPETICAO DE CODIGO, FAZENDO COM QUE NAO SEJA NECESSARIO IMPLEMENTAR NOVAMENTE O METODO QUE TEM A CLAUSULA DEFAULT
OBS2: PARA DEFINIR UM METODO COMO PADRAO, DEVEMOS ANALISAR O PROBLEMA

COM O USO DA CLAUSULA DEFAULT EM INTERFACE:
- AGORA PODEMOS PROVER REUSO
- AGORA TEMOS UMA FORMA DE HERANCA MULTIPLA
* MAS O COMPILADOR RECLAMA SE HOUVER MAIS DE UM METODO COM A MESMA ASSINATURA, OBRIGAND A SOBRESCREVER
- INTERFACES AINDA SAO BEM DIFERENTES DE CLASSES ABSTRATAS, INTERFACES NAO POSSUEM RECURSOS TIAS COMO CONSTRUTORES E ATRIBUTOS