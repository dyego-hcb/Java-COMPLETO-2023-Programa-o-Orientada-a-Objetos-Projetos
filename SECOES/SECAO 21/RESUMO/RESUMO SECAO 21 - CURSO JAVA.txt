-- RESUMO SEÇÃO 21 - ACESSO A BANCO DE DADOS COM JDBC - DO CURSO JAVA COMPLETO 2023 PROGRAMAÇÃO ORIENTADA A OBJETOS + PROJETOS --

VISAO GERAL DO JDBC:
JDBC(JAVA DATABASE CONNECTIVITY): API PADRAO DO JAVA PARA ACESSO DE DADOS
PACOTES: JAVA.SQL E JAVAX.SQL(API SUPLEMENTAR PARA SERVIDORES)

BASE DO JDBC:
                |JAVA APPLICATION|
                        |
                        V
                |JDBC DRIVER MANAGER|
                        ^
                        |
    _____________________________________________
    |                   |                       |
    V                   V                       V
|JDBC DRIVER |      |JDBC DRIVER |          |JDBC DRIVER |       
|(POSTGRESQL)|      |(ORACLE)    |          |(SYBASE)    |
    |                   |                       |
    V                   V                       V
|POSTGRESQL|        |ORACLE DATABASE|       |SYBASE DATEBASE|
|DATABASE  |

ONDE CRIAMOS A NOSSA APP JAVA E O JDBC VAI PERMITIR PROGRAMR O ACESSO A DADOS DE UMA FORMA UNICA
DEVEMOS INTALAR UM DRIVER DO JDBC PARA QUE CONVERTA O CODIGO UNICO PARA OS BANCOS DE DADOS ESPECIFICOS COMO CITADOS NO DIAGRAMA ACIMA, COM ISSO O JDBC CONVERTE PARA AS LINGUAGENS ESPECIFICAS

ALGEBRA RELACIONAL E SQL (NIVELAMENTO):

DOM -> DIAGRAM OBJETCT MODEL (DIAGRAMA DE OBJETOS MODELO)
AS LINGUAGENS OO GERALMENTE TEM UMA TECNOLOGIA NA QUAL TRABALHAMOS NA LINGUAGEM MAS ACESSAMOS OS DADOS DE FORMA PARECIDA AO SQL E ALGEBRA RELACIONAL
OS OBJETOS GERALMENTE EM APLICACOES DE MERCADO, SAO MAPEADOS COM TABELAS DE UM BD RELACIONAL, ONDE TEMOS AS TABLEAS E SEUS RELACIONAMENTOS COM CHAVES PRIMARIAS E ESTRANGEIRAS, DIFERENTEMENTE DO DIAGRAMA DE CLASSE QUE NAO TEM AS CHAVES ESTRANGEIRAS

OPERACOES BASICAS DE ALGEBRA RELACIONAL
- RESTRICAO
- PROJECAO
- PRODUTO CARTESIANO
- JUNCAO(PRODUTO CARTESIANO + RESTRICAO DE CHAVES CORRESPONDENTES)

OPERACO PRODUTO CARTESIADO EM SQL:
SELECT * FROM NOME_TABELA1, NOME_TABELA2

OBS1: SELECT * PEGA TODOS OS ELEMENTOS DAQUELA TABELA

OPERACAO JUNCAO EM SQL:
SELECT * FROM NOME_TABELA1, NOME_TABELA2 WHERE NOME_TABELA1.ATRIBUTO_TABELA 1 = NOME_TABELA2.ATRIBUTO_TABELA2

ONDE PEGAR OS VALORES QUE SATISFAZEM ALGUMA CONDICAO IMPLICADA NO WHERE

PODEMOS REALIZAR A JUNCAO TAMBEM COM A CLAUSULA INNER JOIN, SUA SINTAXE FICARIA A SEGUINTE:
SELECT * FROM NOME_TABELA1 INNER JOIN NOME_TABELA2 APELIDO_TABELA ON NOME_TABELA1.ATRIBUTO_TABELA 1 = APELIDO_TABELA.ATRIBUTO_TABELA2

OBS1: PODEMOS COLOCAR UM APLEIDO NAS TABELAS, ISSO E MUITO UTIL, POIS PODE HAVER TABELAS COM NOME UM POUCO GRANDE E FICARIA DIFICIL DE ENTENDER NO CODIGO DEVIDO O TAMANHO DO NOME

OPRACAO RESTRICAO:
SELECT * FROM NOME_TABELA1, NOME_TABELA2 WHERE NOME_TABELA1.ATRIBUTO_TABELA 1 = NOME_TABELA2.ATRIBUTO_TABELA2 WHERE NOME_TABELA1.NOME_ATRIBUTO1 = 'NOME_PESQUISA'

OBS1: O WHERE E A QUE FAZ A RESTRICAO

OPRACAO DE PROJECAO:
SELECT * FROM NOME_TABELA1.*, NOME_TABELA2.ATRIBUTO_TABELA2 WHERE NOME_TABELA1.ATRIBUTO_TABELA 1 = NOME_TABELA2.ATRIBUTO_TABELA2 WHERE NOME_TABELA1.NOME_ATRIBUTO1 = 'NOME_PESQUISA'

OBS1: PODEMOS UTILIZAR OPERACOES DE PROJECAO PARA PEGARMOS ATRIBUTOS ESPECIFICOS, NA CLAUSULA SELECT E ONDE DEFINIMOS QUAIS ATRIBUTOS IREMOS PEGAR, O .* PEGA TODOS OS CAMPOS

INSTALACAO DO MYSQL:
PARA INSTALAR O MYSQL EM NOSSA MAQUINA, DEVEMOS IR NO SITE OFICIAL DA MSQL(https://dev.mysql.com/downloads/), EM MSQL COMMUNITY SERVER -> GO TO DOWNLOAD PAGE -> MSI INSTALLER FULL
OBS1: NO MAC VAI DEPENDER DA VERSAO POIS HA VERSOES DE MACOS QUE NAO FUNCIONAM O WORKBANCH ATUAL, DEVE-SE PROCURAR A VERESAO DO MYSQL IGUAL A DO WORKBANCH QUE FUNCIONE

PREPARACAO DO PROJETO NO ECLIPSE:

PARA CRIAR UM DATA BASE, UTILIZAMOS O COMOANDO CREATE DATA BASE NOME_DATABASE NO MYSQLWORKBANCH
OBS1: AO CLICKAR NO RAIO DO MYSQLWORKBANCH EXECUTA O COMANDO QUE ESTA NA QUERRY

PARA CONCECTARMOS NOSSAS APPLICACOES JAVA COM O BD, DEVEMOS BAIXAR O JAVA CONNECTOR PARA AQUELE BD, NO CASO DA VIDEO AULA, IREMOS UTILIZAR O JAVA CONNCECTOR DO MYSQL

OBS1: PARA DEFINIR UMA BILBIOTECA CUSTOMIZADA, QUE E BILBITECAS EXTERNAS DEVEMOS IR EM PREFERENCIAS -> JAVA -> BLUIDPATH -> USERLIBARY -> NEW -> E SELECIONA O ARQUIVO JAR 

AGORA PARA CIRARMOS UM PROJETO, DEVEMOS IR EM NEXT, E DEPOIS IR EM ADICIONAR BILBIOTECA, SELECIONAR A BILIOTECA DE USUARIO E SLECIONAR O MYSQLCONNECTOR QUE FOI ADICIONADO A POUCO
OBS1: QUANDO CRIAMOS UM PROJETO COM ESSA BLIBIOTECA EXTERNA, PODEMOS NOTAR QUE TEMOS 2 ARQUIVOS JAVA O DO JRE E DO MYSQLCONNECTOR

DEVEMOS CRIAR NA PASTA RAIZ DO PROJETO, UM ARQUIVO CHAMADO DB.PROPETIES CONTENDO OS DADOS DA CONEXAO:
USER
PASSWORD
DBURL
USESSL=FALSE

DEVEMOS SEMPRE CIAR UM PACOTE DB RESPONSAVEL PELAS VERIFICACOES DO DB, COMO ALGUMA POSSIVEL EXECAO DE CONEXAO E CODIGO PARA OBTER E FECHAR CONEXAO COM O BD

OBS1: DEVE-SE TRATAR AS EXECOES DE NAO ENCONTRAR O ARQUIVO .Properties E E IOEXPETION, POREM A IOEXPETION VALE APRAS AS 2

AO CIRAR UMA FUNCAO DE CONEXAO, VERIRICAMOS SE A NOSSA VARIAVEL CONEXAO ESTA NULA OU NAO SE ESTIVER E PORQUE NAO TEM AI CHAMAMOS A  FUNCAO LOADPROPETIS
PARA CONECTAR COM O BD, PRECISAMOS PEGAR A URL QUE ESTA CONTIDA NO ARQUIVO Properties, NO ATRIBUTO DBURL, E ATRIBUIMOS A NOSSA VARIVEL CONN QUE E DO TIPO CONNECTION O DRIVE.MANAGER,GETCONNECTION(URL, PROPS)
ONDE PROPS E O RESTANTE DA Properties
CONCTAR NO DB E INSTANCIAR UM OBJETO DO TIPO CONNECTION
PARA ENCERRAR UMA CONEXAO COM O DB BASTA VERIFICAR SE A CONEXAO NAO E NULA E DAR O .CLOSE

OBS1: E BOM CRIAR EXECOES PERSONALIZADAS PARA A CONEXAO COM O DB POIS NAO TEREMOS QUE FICAR COLOCANDO VARIOS TRY-CATCHS APENAS SE NECESSARIO
OBS2: SE INFORMARMOS DADOS ERRADO DA ERRO DE CONEXAO

RECUPERAR DADOS:
NESSA ETAPA, VAMOS VER COMO RECUPERAR DADOS DO BANCO MYSQL PARA UMA APLICACAO JAVAX, PARA ISSO PRECISAMOS CRIAR ALGUMAS TABELAS NO NOSSO BANCO E POPULA-LAS, NA VIDEO AULA O PROFESSOR DEIXOU UM ARQUIVO MYSQL COM OS COMANDOS DE CRIACAO DA TABELA E POPULARIZACAO DA MESMA.
NO MYSQL WORKBANCH, DEVEMOS ABRIR A CONEXAO COM O SERVIDOR, INFORMANDO A SENHA CADASTRADA, DEPOIS DEVEMOS SELECIONAR QUAL DB VAMOS USAR, PARA SELECIONAR BASTA DAR 2 CLICKES OU UTILZIAR O SCPRIT USE NOME_DB.
APOS ISSO, DEVEMOS CRIAR NOSSA ESTRUTURA DE DADOS NO JAVA, COMO AS CLASSES QUE SAO AS TABELAS DEVEM SER CRIADAS NA APLICACAO VISTO QUE JAVA E OO, ENTAO PODEMOS CRIAR CLASSES DAS TABELAS

UTILIZA-SE O COMANDO EM SQL EM STRING SELECT NOME_ATRIBUTO(OU * PARA PEGAR TODOS) FROM NOME_TABELA WHERE SE NECESSARIO
OBS1: NO MYSQL WORKBANCH AO CLICKAR NA TABELA COM O BOTAO DIREITO E NA OPCAO SELECT ROWS, MOSTRA TODAS AS LINHAS COM LIMITE MAXIMO DE 1000 DESSA TABELA, OU SEJA, MOSTRA SEUS ATRIBUTOS E OS VALORES CASO ESTEJAM POPULADOS

PARA TRABALHAR COM RECUPERACAO DE DADOS, DEVEMOS ENTENDER DUAS CLASSES:
1- STATEMENT -> PARA MONTAR UM COMANDO SQL A SER EXECUTADO
2- RESULTSET -> REPRESENTA UM OBJETO CONTENDO O RESULTADO DA CONSULTA NA FORMA DE TABELA(COLUNAS E LINHAS)
RESULTSET POSSUI ALGUMAS OPERACOES, VISTO QUE SEUS DADOS SAO RETORNADO EM FORMA DE TABELA(COLUNAS E LINHAS) TAIS COMO:
* FRIST() -> MOVE 1 POSICAO SE HOUVER (PRIMEIRA POSICAO ONDE TEM DADOS, SE RETORNAR NADA NAO TEM POSICAO 1)
* BEFOREFRIST() -> MOVE PARA POSICAO 0 (COMECO ANTES DE COMECER OS DADOS)
* NEXT() -> MOVE PARA O PRIXIMO, RETORNA FALSE SE ESTIVER NO ULTIMO (UTIL PARA PERCORRER O RESULSET)
* ABSOLUTE(INT) -> MOVE PARA A POSICAO DADA, LEMBRANDO QUE DADOS REAIS COMECAM EM 1

OBS1: OPERACOES SEMPRE DO BLOCO TRY POIS PODEM ATIVAR ALGUMA EXECAO DEVIDO A CONEXAO COM O BD EXTERNO
OBS2: PARA PEGARMOS ALGUM VALOR DA TABELA QUANDO RECUPERADA, PRECISAMOS UTILIZAR OS METODOS GET DO RS(RESULSET) PODENDO TER O VALORES INTEIRO, STRING, ETC.
OBS3: DEVE-SE FECHAR OS RECURSOS NA SEGUINTE ORDEM RS, ST, DB, E TRATAR AS EXECOES DE TENTAR FECHAR O RS E ST POIS PODEM ACABAR GERANDO ALGUMA EXECAO
OBS4: PARA NAO TERMOS QUE FICAR FAZENDO VARIOS TRY-CATCHS, PODEMOS CRIAR METODOS PARA FECHAR OS RECURSOS NA PROPRIA CLASSE DO DB, POIS A CLASSE DO DB E DO TIPO RUNTIMEEXEPTION OU SEJA, NAO PRECISA FICAR TRATANDO TODA HORA

INSERIR DADOS:
PARA INSERIRMOS DADOS NO DB, IREMOS UTILIZAR AS SEGUINTES API DO JDB:
* PREPAREDSTATEMENT -> OBJETO QUE MONTA CONSULTA SQL COM PARAMENTRO PAARA MONTAR DEPOIS
* EXECUTEUPDATE ->
* STATEMENT.RETURN_GENERATED_KEYS -> RECUPERAR O ID DO OJBETO INSERIDO
* GETGENERATEDKEYS -> 

OBS1: PARA INSERIRMOS NO DB DEVEMOS INSTANCIAR UM OBJETO PREPAREDSTATEMENT, DIFERENTEMENTE DO PASSO ANTERIOR QUE ERA RECUPERACAO DE DADOS EM QUE USAMOS UM STATEMENT
APOS INSTANCIARMOS A CONECAXAO E O PREPAREDSTATEMENT COMO NULO, IREMOS CONECTAR NO BANCO, ATRAVEZ DA NOSSA VARAIVEL CONN
DEPOIS IREMOS UTILIZAR UMA FUNCAO DA CLASSE CONNECTION CAHAMDA PREPARESTATIMENT(COMANDO_SQL) ONDE PASSAMOS UMA STRING COMO UM COMANDO SQL PARA O BD

OBS1: AO INSERIR UTILIZANDO O SEGUINTE COMANDO SQL EM STRING INSERT INTO NOME_TABELA (NOME_ATRIBUTO) VALUE (?), DEVEMOS COLOCAR (?, ?) NOS CAMPOS QUE IREMOS COLOCAR OS VALORES POIS IREMOS COLOCAR O VALOR DEPOIS

DEFINIMOS OS VALORES QUE COLOCCAREMOS NOS ? ATRAVES DOS COMANDOS .SET DO PREPAREDSTATEMENT, CABE DEFINIR QUAL O TIPO CORRETO E A POSICAO DO ? QUE VOCE DESEJA INSERIR

OBS1: QUANDO UTILIZAMOS O JDBC PARA ARQUIVOS MSQL, PARA INSTANCIARMOS UMA DATA NAO UTILIZAMOS O DATE DO PACOTE UTIL E SIM O DO PACOTE SQL

PARA EXECUTAR O COMANDO SQL DO PREPAREDSTATEMENT, BASTA CHAMAR O METODO .EXECUTEUPDATE

OB1: QUANDO E UMA OPERACAO EM QUE IREMOS ALTERAR OS DADOS, UTILIZAMOS O .EXECUTEUPDATE, QUE RETORNA UM INTEIRO DE QUANTAS LINHAS FORAM ALTERADAS

PARA FECHAR A CONEXAO DE UM PREPAREDSTATEMENT PODE-SE UTILIZAR O FECHAMENTO DE CONEXAO DO STATEMENT

PODEMOS RETORNAR O VALOR DO ID DE UM OJBETO INSERIDO NA TABELA, COLOCANDO APENAS O COMANDO STATIMENT.RETURN_GENERATED_KEYS APOS OS (?)
E PARA RECUPAR ESSE VALOR DEVEMOS ARMAZENAR NUMA VARIAVEL RS, POIS E BASICAMENTE O RESULTADO DE UMA CONSULTA, VISTO QUE RETORNA O VALOR DO ID DAQUELE NOVO OBJETO DA TABELA, E PODE RETORNAR 1 OU MAIS VALORES
AO UTILZIAR A FUNCAO GETGENERATEDKEYS, RETORNA APENAS OS ID DE TODOS OS OBJETOS DA TABELA

ATUALIZAR DADOS:
PARA ATAULIZAR DADOS NO BANCO, TAMBEM UTILIZAMOS O PREPAREDSTATEMENT
MESMA COISA PRA INSERIR, UNICA COISA QUE MUDA E O COMANDO EM INSERCAO USAMOS O INSERT INTO E NA ATAULIZACAO UTILIZAMOS O UPDATE NOME_TABELA SET NOME_ATRIBUTO = ? WHERE LOGICA DO WHERE

OBS1: JAMAIS FAZER UPDATE SEM WHERE POIS ALTERA TODAS AS LINHAS DA TABELA !!

DELETAR DADOS:

PARA DELETAR ALGUM DADO DO BD EM JAVA, DEVEMOS CRIAR UMA EXECAO PERSONALIZADA CHAMADA DBINTEGRITYEXCEPTION, POIS E MUITO COMUM EM DELECOES EM BD QUE ACONTECE UM PROBLEMA DE INTEGRIDADE REFERENCIAL
A FALHA DE INTEGRIDADE REFERENCIAL E QUANDO UMA CHAVE ESTRANGEIRA NAO EXISTE, PARA ISSO CRIAREMOS A EXECAO ACIMA CITADA

ESSA EXECAO E UMA EXECAO DO TIPO RUNTIMEEXEPTION

SCRIPT DE DELECAO SQL EM STRING "DELETE FROM NOME_TABELA WHERE NOME_ATRIBUTO = ? "

O RESTANTE E IGUAL O DE UPDATE E INSERT, MUDANDO APENTAS O SCRIPT SQL EM STRING

AO TENTAR EXCLUIR ALGUM ELEMENTO DA TABELA, ONDE O MESMO E UMA CHAVE ESTRANGEIRA OCORRE UMA EXECAO, E AO LANCARMOS A NOSSA EXECAO PERSONALIZADA, TEMOS UMA MSG BEM EXPLICATIVA MOSTRANDO ONDE OCORREU AQUELA EXECAO E QUAL MOTIVO
ACIMA FAZ COM QUE NAO OCORRA A FALHA DE INTEGRIDADE REFERENCIAL

OBS1: JAMAIS FAZER DELETE SEM WHERE POIS DELETA TODAS AS LINHAS DA TABELA !!!

TANSACOES:
A TRANSACAO POSSUI 4 PROPRIEDADES:
1- ATOMICA -> OU ACONTECE TUDO OU NAO ACONTECE NADA
2- CONSISTENTE 
3- ISOLADA
4- DURAVEL

TRANASAO POR EXEMPLO DE TRANSFERENCIA
ONDE CNSISTE EM 2 PASSO
DEBITAR DA MINHA CONTA
E DEPOSITAR NA CONTA DA MARIA
PORE HAVER ERRO NO SISTEMA E O PROCESSO E INTERROMPIDO
NA MINHA PERDEU DINHEIRO
E MARIA NAO TEM O DINHEIRO DEPOSITADO
FICANDO COM DADOS INCOSTENTE
PARA GARANTIR QUE ESSA TRANSFERENCIA SEJA CONSISTENTE DEVEMOS UTILIZAR TRANSLACOES

PARA UTILZIAR A TRANSACOES UTILIZAMOS OS 3 ELEMENTOS DA API:
* SETAUTOCOMMIT(FALSE) -> CADA OPERACAO ISOLADA QUE FIZER ELA E CONFIRMADA AUTOMATICAMENTE QUANDO TIVER TRUE, QUANDO TIVER FALSE CADA OPERACAO NAO ESTA CONFIRMADA SO QUANDO CONFIRMAR FECHA A TRANSACAO
* COMMIT() -> CONFIRMAR TRANSACAO
* ROLLBACK() -> DESFAZER O QUE FOI FEITO ATE O MOMENTO

PARA UTILZIAR TRANSACAO EM JAVA, DEVEMOS PRIMEIRAMENTE DEFINIR O SET AUTO COMMIT COMO FALSE, POIS DEVEMOS SEMPRE CONFIRMAR A TRANSACAO E NAO DEIXAR ISSO DE MANEIRA AUTOMATICAMENTE
PARA CONFIRMAR A TRANSACAO, DEVEMOS COLOCAR O COMMIT() NO FINAL DA TRANSACAO
COM ISSO, NO TRATAMENTO DA EXECAO, DEVEMOS IMPLEMENTAR UMA LOGICA PRA VOLTAR O BD PARA UM ESTADO EM QUE NAO TENHA OCORRIDO O ERRO CASO OCORRA
UTILZIANDO A FUNCAO ROLLBACK E PODEMOS ACIONAR UMA EXECAO E MOSTRAR A MSG DO PORQQUE A TRANSACAO NAO FOI CONCLUIDA E VOLTA O BD

OBS1: PODEMOS TENTAR FAZER ROLLBACK E PODE DAR ERRO, PORE ISSO DEVEMOS TRATRAR ESSA EXECAO

PADRAO DE PROJETO DAO(DATA ACESS OBJECT):
IDEIA PADRAO DO DAO:
- PARA CADDA ENTIDADE, HAVERA UM OBJETO RESPONSAVEL POR FAZER ACESSO A DADOS RELACIONADOS A ESTA ENTIDADE. POR EXEMLO:
* CLIENTE -> CLIENTEDAO -> RESPOSNAVEL PORE ACESSO A DADOS NO BD BUSCAR, INSERIR ATUALIZAR, ETC
* PRDODUTO -> PRODUTODAO
* PEDIDO -> PEDIDODAO

- CADA DAO SERA DEFINIDO POR UMA INTERFACE, POIS O ACESSO A DADOS PODE MUDAR, POR ISSO DEVE-SE USAR INTERFACE POIS E MAIS MALEAVEL A MUDANCAS E PRESERVA O CONTRATO DA INTERFACE
- A INJECAO DE DEPENDECIA PODE SER FEITA POR MEIO DO PADRAO DE PROJETO FACTORY, RESPONSAVEL POR INSTANCIAR O DAO

OBS1: PODEMOS TER DAO'S GENERICOS PARA EVITAR REPLICACAO DE CODIGO

PROJETO JDBC COM PADRAO DAO:

O PROJETO JDBC ESTARA NO REPOSITORIO NO GITHUB NO SEGUINTE LINK: https://github.com/zebodexx/Projeto-DAO-JDBC

IREMOS DESCREVER O PASSO A PASSO DE DESENVOLVMENTO DESTE PROJETO ABAIXO.

NESSE PROJETO DAO, IREMOS IMPLENTAR UM SISTEMA DE VENDEDORES QUE POSSUEM DEPARTAMENTO

PASSO 1: CRIAR A CLASSE DEPARTAMENTO, IMPLEMENTAR OS ATRIBUTOS, CONSTRUTUORES, GETTERS/SETTERS, HASHCODE AND EQUALS(PARA VERIFICAR SE SAO IGUAIS POR CONTEUDO), TOSTRING, IMPLEMENTS SERIALIZABLE
OBS1: O SERIALIZABLE DEVE SER IMPLEMENTADO PARA QUE SEJA POSSIVEL CONVERTER O OBJETOS EM SEQUENCIA DE BYTES PARA SER GRAVADO EM ARQUIVO, TRANSFERIDO EM REDE, ETC

PASSO 2: CRIAR A CLASSE SELLER, IMPLEMENTAR AS MESMAS COISAS DO PASSO 1 POREM COM OS DADOS DO SELLER
PASSO 3: IMPLEMENTAR DEPARTAMENTDAO AN SELLERDAO INTERFACE
OBS1: IREMOS CRIAR APENAS AS INTERFACES NESSA ETAPA
OBS2: O MODEL COMPREENDE AS CLASSES QUE FAZEM TRANSFORMACOES DE ENTIDADE
OBS3: COMO DITO ANTERIORMENTE, NO DAO FICAM AS OPERACOES DE INSERCAO, DELETE, UPDATE, FINDBYID E FINDBYALL, ETC, PODE HAVER MAIS DEPENENDO DA LOGICA DO PROJETO, ESSAS SAO AS OPERACOES MAIS BASICAS QUE PODEM SER TRANSFORMADAS PARA GENERICAS E UTIIZAR APENA 1 CODIGO E NAO REPLICALO

PASSO 4: CRIAR A CLASSE SELERDAOJDBC AND DAOFACTORY, A CLASSE SELLERDAOJDBC IRA REALIZAR A IMPLEMENTACAO DOS METODOS DA INTERFACE SELLERDAO, A CLASSE DAOFACTORY SERA RESPONSAVEL POR INSTANCIAR OS DAO'SAO
OBS1: A FABRICA E UMA CLASSE AUXILIAR RESPONSAVEL POR INSTANCIAR DAOS, ELA TEM OPERACOES ESTATICAS PARA INSTANCIAR OS DAOS, ONDE ELA EXPOE UM METODO QUE REOTNRA UM TIPO DA INTERFACE, MAS INTERNAMENTE ELA INSTANCIA UMA IMPLEMENTACAO, ISSO E FEITO PARA GERAR TRANSPARENCIA PARA O PROGRAMA, ONDE O PROGRAMA NAO CONEHCE A IMPLEMENTACAO APENAS A INTERFACE
OBS2: O FATO DITO ACIMA E MUITO USADO EM BOAS PRATICAS DE PGORAMACAO, VISTO QUE TRANSPARENCIA E MUITO USADO ATUALMENTE, POIS NAO DEVEMOS MOSTRAR TUDO AO USUARIO

PASSO 5: IMPLEMENTAR O FINDBYID
OBS1: PODEMOS COLOCAR NOME NOS ATRIBUTOS NO MYSQL COM O AS NOME_APLEIDO
OBS2: NA CLASSES DAO, DEVEMOS CRIAR UM ATRIBUTO CONN E OBRIGAR O USUARIO A PASSAR PELO CONSTRUTOR, VISTO QUE NA CLASSE DAO OCORRE AS OPERACOES DE BD DE FORMA TRASNAPARENTE AO USUARIO
OBS3: EM OO, DEVEMOS TER OS OBJETOS ASSOCIADOS, CRIAR ESSES OBJETOS NA MEMORIA, DEVEMOS SEMPRE-E INSTANCIA-LOS NA MEMORIA
OBS4: QUANDO EXECUTAMOS UMA CONSULTA SQL E RETORNA UM RESULTSET, ELE RETONRA 2 POSICOES CASO TENHA OBJETO, A POSICAO 0 NAO TEM OBJETO, APENAS NA PROXIMA, DEVE-SE USAR O NEXT()
OBS5: PODEMOS CRIAR FUNCOES DE INSTANCIACAO DE OJBETOS NA CLASSE DAOJDBC PARA QUE FIQUE SEPARADO CADA FUNCIONALIDADE, E PARA QUE SEJA POSSIVEL TAMBEM REEAPROVEITAR O CODIGO COM APENAS CHAMADAS DE FUNCOES
OBS6: NO PROGRAMA QUE FECHAMOS A CONEXAO

PASSO 6: RESUING INSTANTIATION -> COMO DITO ANTERIORMENTE, PODEMOS CRIAR FUNCOES PARA INSTANCIAR OS OBJETOS, FAZENDO COM QUE CADA FUNCIONALIDADE FIQUE BEM DEFINIDA E TAMBEM E POSSIVEL REUTILZIAR ESSA FUNCAO, COMO POR EXEMPLO PRA INSERIR UM NOVO OBJETO, DEVE-SE TRATAR A EXECAO DE MODO DE PROPAGACAO
PASSO 7: IMPLEMENTAR O FINDBYDEPARTAMENT -> BASICAMENTE COMO IMPLEMENTAMOS O FINDBYID POREM COM A LOGICA PARA ACHAR O DEPARTAMENTO
OBS1: OBJETOS ASSOCIADOS CORRETAMENTE E QUANDO POR EXEMPLO TEMOS 3 VENDENDOR QUE APONTA PARA O DEP 2, OU SEJA OS 3 APONTAM PARA O DEP 2 E NAO TEMOS 3 DEPS 2
OBS2: PARA NAO REPETIR O DEP DE COMO EXEMPLIFICAMOS, DEVEMOS CONTROLAR A NAO REPETICAO DE VALORE UTILIZAND A ESTRUTURA MAP
OBS3: ANTES DE INSTANCIARMOS O DEPARTEMENTO, DEVEMOS VERIFICAR NO MAP SE EXISTE, CASO EXISTA E PQ REPETIU E SE FOR NULL NAO EXISTE ADICIONADO

PASSO 8: IMPLEMENTAR O FINDALL -> BASICAMENTE FEITO ANTERIORMENTE, MUDA POUCA COISA DO CODIGO DO PASSO ANTERIOR, ALTERANDO O CODIGO SE NECESSARIO
PASSO 9: IMPLEMENTACAO DO INSERT -> RECEBEMOS UM OBJETO POR PAREMETRO, BASTA UTILIZAR OS GET PARA CADA CAMPO DA TABELA
OBS1: COMO TEMOS O ID NA CLASSE DO OJBETO, DEVEMOS PEGAR O VALOR DO ID NO BANCO E ARMAZENAR NO OBJETO INSTANCIADO EM MEMORIA
OBS2: AO INSTANCIAR UM OBJ NA MEMORIA, QUANDO FOR USA-LO PARA INSERIR NO BD, O ID DEVE-SE NULL

PASSO 10: UPDATE IMPLEMENTATION -> BASICAMENTE IGUAL O INSERT SO MUDA O COMANDO SQL EM STRING E DEVE-SE SEMPRE COLCOAR O WHERE
OBS1: COLOCAR SEMPRE CLAUSULA WHERE NO UPDATE PARA NAO ATAULIZAR TODOS OS DADOS DA TABELA !!!

PASSO 11: DELETE IMPLEMENTATION -> BASEICAMENTE IGUAL O UPDATE SO MUDA O COMANDO SQL EM STRING E DEVE-SE COLOCAR O WHERE PARA NAO EXCLUIT TODOS OS INTENS DA TABELA
OBS1: DELETE SEMPRE TEM QUE TER CLAUSULA WHWRE
OBS2: SE TETNTAR DELETAR UM OBJETO QUE NAO EXISTE, CABE AO PROGRAMADOR DEFINIR SE MOSTRA OU NAO A MSG FALANDO QUE NAO EXISTIA AQUELE OBJETO NO BD

PASSO 12: DEPARTAMENTDAO IMPLEMENTATION AND TEST -> IMPLMENTACAO DOS METODOS DO DEPARTAMENTDAO, MAIS SIMPLES POIS E UMA CLASSE INDEPENDENDE, A CALSSE ANTERIROR ERA DEPENDETE DESSA 