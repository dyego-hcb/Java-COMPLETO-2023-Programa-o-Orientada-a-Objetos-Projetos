-- RESUMO SEÇÃO 19 - GENERICS, SET, MAP - DO CURSO JAVA COMPLETO 2023 PROGRAMAÇÃO ORIENTADA A OBJETOS + PROJETOS --

GENERICS:
GENERICS PERMITEM QUE CLASSES, INTERFACES E METODOS POSSAM SER PARAMETRIZADOS POR TIPO, SEUS BENEFICIOS SAO:
- REUSO
- TYPE SAFETY
- PERFORMACE

USO COMUM EM COLECOES(ARRAYS)

REUSO -> POIS COMO DEFINIMOS UM TIPO PARA RETORNO OU COMO PARAMETRO, DEVE-SE CRIAR OUTRA CLASSE PARA CASO QUEIRA MANIPULAR OUTRO TIPO DE VARIAVEL OU PAREMETRO, CAUSANDO O PROBLEMA DE REUSO
OBS1: PODEMOS ACABAR COM O REUSO UTILIZANDO OBJECT COMO O TIPO DE UMA VARIAVEL, VISTO QUE E POSSIVEL INSTANCIAR DIVERSOS OBJETOS DO TIPO OBJECT, POREM OCORRE O TYPESAFETY
OBS2: TYPESAFETY E QUANDO USAMOS O TIPO OBJECT PARA TENTAR RESOLVER O REUSO, ELE NAO RESOLVE DA MELHOR FORMA POSSIVEL, ALEM DO TYPESAFE QUE E QUANDO UM OBJETO NAO PODE SER CONVERTIDO PARA OUTRO, TAMBEM TEMOS PROBLEMAS COM A PERFORMACE DEVIDO AOS DOWN E UPPER CASTING

O GENERIC PODE ACABAR COM O REUSO POIS A GENTE PARAMETRIZA UM TIPO QUE QUE PODE SER UM TIPO QUALQUER, GARANTINDO QUE HAJA REUSO E QUE NAO CAIA NO TYPESAFE, POIS SE VOCE DIGITAR UM GENERIC QUE RECEVE UM TIPO T INTEIRO POR EXEMPLO ELE SO VAI ACEITAR INTEIRO
OBS1: DEVEMOS COLOCAR O <T> NO FINAL DO NOME DA CLASSE PARA DEFINI-LA COMO UMA CLASSE GENERICA E ALTERAR TODOS OS RETORNOS E PARAMETOS PARA O TIPO TAMBEM
OBS2: AO INSTANCIAR UM TIPO GENERICO, DEVEMOS COLOCAR O <> NO FINAL DA INSTANCIACAO E PASSAR O TIPO NO MOMENTO DA INSTANCIACAO

GENERICOS DELIMITADOS:

E CRIAR NOVAS REGRAS DE COMPARACOES PARA OBJETOS, VISTO QUE CADA OBJETO PODE-SE COMPARAR DE DIFERENTES FORMAS

OBS1: METODOS ESTATICOS NAO PRECISAM SER INSTANCIADOS PARA SER CHAMADO
OBS2: PARA FALAR QUE UM METODO ESTATICO E GENERICO, DEVELSE COLOCAR <T> ANTES DO TIPO T QUE REFERE-SE AO RETORNO
OBS3: CASO USE OPERACOES DE COMPARABE, NO <T> DEVEMOS ADICIONAR O SEGUINTE EXTENDS <T EXTENDS COMPARABLE<T>>, ELE FAZ COM QUE SEJA POSSIVEL COMPARA QUALQUER T DESDE QUE T SEJA SUBTIPO DE QUALUQER TAMBEM
OBS4: QUANDO COLOCAMOS ALGUM METODO QUE POSSUI A EXTENCAO COMPARABLE<T> DEVEMOS IMPLEMENTAR NA CLASSE O IMPLEMENTS COMPARABLE<TIPO_DA_CLASSE> E IMPLEMENTAR O METODO DE COMPARAR
OBS5: VERSAO COMPLETA DO EXTENDS T <T EXTENDS COMPARABLE< ? SUPER T>> POIS E UM TIPO COMPARAVEL T OU QUALQUER SUPER CLASSE DE T

TIPOS CURINGA (WILDCARD TYPES):

COM TIPOS CURINGA(?) PODEMOS FAZER METODOS QUE RECEBEM UM GENERICO DE QUALUQER TIPO, FAZ COM QUE MEIO QUE FACA UM DOWNCASTING PARA OBJETCT
POREM NAO E POSSIVEL ADICIONAR DADOS A UMA COLECAO DO TIPO CURINGA, POIS A COLECAO DO TIPO CURINGA NAO SABE AO CERTO QUAL O TIPO DA LISTA QUE FOI INSTANCIADO

GENERICS SAO INVARIANTES
List<Object> não é o supertipo de qualquer tipo de lista:
List<Object> myObjs = new ArrayList<Object>();
List<Integer> myNumbers = new ArrayList<Integer>(); -> SUBTIPO DE OBJECT
myObjs = myNumbers; // erro de compilação -> PORQUE O LIST OBJECT NAO E UM SUPERTIPO DE LIST INTEGER

O supertipo de qualquer tipo de lista é List<?>. Este é um tipo curinga:
List<?> myObjs = new ArrayList<Object>();
List<Integer> myNumbers = new ArrayList<Integer>();
myObjs = myNumbers;

TIPOS CURINGA DELIMITADOS(BOUNDED WILDCARD):

BASTA DAR UM EXTENDS NO ?, FICANDO <? EXTENDS NOME_CLASSE>, ISSO FAZ COM QUE O COMPILADOR ENTENDA QUE E UMA LISTA DE QUALQUER SUBTIPO DE SHAPE

OBS1: SAO SOLUCAES IMPROPRIA COLOCAR COLOCAR COMO PARAMETRODO DE UM METODO LISTAS CURINGAS OU INT LISTA DE UM DETERMINADO OBJETO GENERICO 
OBS2: NAO CONSEGUIREMOS ADD ELEMENTOS NA LISTA DO METODO, POIS PODE SER SUBTIPO DIFERENTE

PRINCIPIO GET/PUT:

COVARIANCIA ->  CLAUSULA EXTENDS POSSIVEL ERRO DE COMPATIBLIDADE, FAZENDO COM QUE A OPERACAO DE PUT NAO SEJA POSSIVEL, POREM A OPERACAO DE GET SIM
CONTRAVARIANCIA -> CLAUSULA SUPER QUANDO USAMOS A CLAUSLA <? SUPER NOME_CLASSE> DEFINE QUE PODEMOS ADICIONAR QUALUQER VALOR QUE SEJA DO SUPER TIPO DA CLASSE, POREM NAO PODEMOS ACESSAR OS OBJETOS DA LISTA, POIS O TIPO PODE SER UM TIPO QUE UM SUPER TIPO DA CLASSE

OBS1: JAVA WRAPPER TYPES SAO OS TIPOS CORRESPONDENTES AO TIPO PRIMITIVOS
OBS2: COVARIANCIA -> SUBTIPOS PARA ACESSAR
OBS3: CONTRAVARIANCIA -> SUPER TIPOS QUE PODEM ADD

HASHCODE E EQUALS:

SAO OPERACOES DA CLASSE OBJECT UTILIZADAS PARA COMPARAR SE UM OBJETO E IGUAL A OUTRO

- EQUALS -> LENTO, RESPOSTA 100% (NAO ERRA)
- HASHCODE -> RAPIDO, POREM RESPOSTA POSITIVA NAO E 100% (PEQUENA PROBABILDADE DE FALSO POSITIVO)

TIPOS COMUNS (STRING, DATE, INTEGER, DOUBLE, ETC) JA POSSUEM IMPLEMENTACAO PARA ESSAS OPERACOES, CLASSES PERSONALIZADAS PRECISAM SOBREPOLAS

EQUALS -> METODO QUE COMPARA SE O OBJETO E IGUAL A OUTRO, RETORNANDO TRUE OR FALSE
HASHCODE -> METODO QUE RETORNA UM NUMERO INTEIRO REPRESENTANDO UM CODIGO GERADO A PARTIR DAS INFORMACOES DO OBJETO 

OBS1: O HASH CODE E UM CODIGO GERADO A PARTIR DE UMA FUNCAO DE GRACAO QUE ESTA DENTRO DA IMPLEMENTACAO DA CLASSE E RETORNA UM INTEIRO, PARA GERAR UM CODIGO HASH A PARTIR DE DADOS, POREM PARA DADOS COM MESMO CONTEUDO TEM QUE DAR O MESMO HASH
OBS2: PODE DAR COLISOES NO HASH CODE, POREM E MUITO DIFICIL VISTO QUE O HASH CODE VISA TENTAR TRATAR O MAXIMO ESSAS COLISOES

REGA DE OURO DO HASHCODE:
SE O HASHCODE DE DOIS OBJETOS FOR DIFERENTES, ENTAO OS DOIS OBJETOS SAO DIFERENTES
SE O CODIGO DE DOIS OBJETOS FOR IGUAL, MUITO PROVAVELMENTE OS OBJETOS SAO IGUALS(PODE HAVER COLISAO, RARO MAS PODE HAVER)

OBS1: NUNCA ACONTECE UM NOME IGUAL RETORNAR UM NUMERO DIFERENTE
OBS2: HASHCODE E BOM PARA TESTAR UMA MASSA MUITO GRANDE DE OBJETOS EM QUE VOCE SABE QUE A MAIORIA E DIFERENTE

POR ISSO EXISTE OS 2 MODOS, 1 E MAIS RAPIDO POREM PODE HAVER COLISOES E O OUTRO E MAIS LENTO POREM E 100% EFICAZ 
OBS1: PODEMOS CRIAR NOSSOS PROPROPS METHODOS DE HASH CODE E EQUALS EM JAVA, ONDE NO EQUALS IREMOS REALZIAR A LOGICA DE IMPLEMNTACAO DAQUELA COMPARACAO, O ECPLISE GERA OS CODIGOS PARA GENTE AUTOMATICAMENTE AO SOLICITA-LO PARA GERAR AS OPERACOES DE HASHCODE E EQUALS
OBS2: QUANDO COMPARAMOS 2 OBJETOS COM O == ELE COMPARA AS REF DE MEMORIA, COMO CRIA-SE 2 OBJETOS DIFERETNES, NA MEMORIA HEAP AMBOS POSSUEM POSICAO NA MEMORIA DIFERENTE
OBS3: SE QUISE COMPARA 2 OBJETOS POR IGUALDE PELO CONTEUDO DO OBJETO USA-SE EQUALS, E PARA COMPARA AS REFERENCAIS DOS OBJETOS USA-SE O ==
OBS4: QUANDO ESCREVEMOS NA EXPRESSAO LITERAL DE UMA FORMA ESPECIAL, ELE TRATA COMO SE FOSSE A MESMA REFERENCIAS NA MEMORIA QUANDO SE USA O ==.

SET:

SET<T>
- REPRESENTA UM CONJUNTO DE ELEMENTOS (SIMILIAR AO DA ALGEBRA)
- NAO ADMITE REPETICOES
- ELEMENTOS NAO POSSUE POSICOES, POREM PODEM EXISTIR ORDEM DEPENDENDO DA IMPLEMENTACAO
- ACESSO, ISERCAO E REMOCAO DE ELEMENTOS SAO RAPIDOS
- OPERACOES EFICIENTES DE CONJUNTO: INTERSECAO, UNIAO, DIFERENCA
- PRINCIPAIS IMPLEMENTACOES:
* HASHSET -> MAIS RAPIDO (OPERACOES O(1) EM TABELA HASH) E NAO ORDENADO
* TREESET -> MAIS LENTO (OPERACOES O(LOG(N) EM ARVORE RUBRO-NEGRA) E ORDENADO PLEO COMPARTETO DO OBJETO(OU COMPARADOR))
* LINKEDHASHSET -> VELOCIDADE INTERMEDIARIA E ELEMENTOS NA ORDEM EM QUE SAO ADICIONADOS

OBS1: O SET E UM TIPO GENERICO IGUAL A LISTA
OBS2: O SET E UMA INTERFACE

ALGUNS METODOS IMPORTANTES:
- ADD(OBJ), REMOVE(OBJ), CONTAINS(OBJ) -> PASSA SEMPRE O OBJETO EM TODAS E AS OPERACOES SAO FEITAS BASEAAS NOS CRITERIOS ABAIXO 
* BASEADO EM EQUALS E HASHCODE
* SE EQUALS E HASHCODE NAO EXISTIR, E USADA COMPARACAO DE PONTEIROS

- CLEAR() -> ESVAZIA O CONJUNTO
- SIZE() -> RETORNA O TAMANHO DO CONJUNTO, QUANTIDADE DE ELEMENTOS 
- REMOVEIF(PREDICATE) -> ELE REMOVE DO CONJUNTO TODO MUNDO QUE ATENDER O PREDICADO PASSADO POR REF
- ADDALL(OTHER) -> UNIAO: ADICIONA NO CONJUNTO OS ELEMENTOS DO OUTRO CONJUNTO SEM REPETICAO
- RETAINALL(OTHER) -> INTERSECAO: REMOVE DO CONJUNTO OS ELEMENTOS NAO CONITDOS EM OTHER
- REMOVEALL(OTHER) -> DIFERENCA: REMOVE DO CONJUNTO OS ELEMENTOS CONTIDOS EM OTHER

OBS1: CONTAINS VERIFICA SE O ELEMENTO ESTA CONTIDO NAQUELE CONJUNTO
OBS2: NO REMOVE IF PASSA-SE O PREDICADO, O PREDICATO E X -> X.SIZE < 3 POR EXEMPLO

COMO SET TESTE IGUALDADE:
AS COLECOES TESTAM IGUADADES COM OS SEGUINTES CRITERIOS:
- SE HASHSCODE E EQUALS ESTIVEREM IMPLEMENTADOS:
* PRIMEIRO HASHCODE, SE DER IGUAL, USA O EQUALS PARA CONFIRMAR
* LEMBRE-SE STRING, INTEGER, DOUBLE, ETC. JA POSSEM EQUALS E HASHCODE

- SE O HASHCODE E EUQLAS NAO ESTIVEREM IMPLEMENTADOS:
* COMPARA AS REF(PONTEIROS) DOS OBJETOS

COMO TREESET COMPARA OS ELEMENTOS: 
UTILIZA-SE OS METODOS COMPARTE TO DO OBJETO, AO IMPLEMENTAR A CLASSE COMPARABLE, OU PELO COMPARTATOR


OBS1: SET NAO DEIXA ADD VALORES REPETIDOS, ADD APENAS UMA VEZ NA LISTA SET

MAP:
MAP<K,V>
- E UMA COLECAO DE PARES DE CHAVE/VALOR
* NAO ADMITE REPETICOES DO OBJETO CHAVE
* OS ELEMENTOS SAO INDEXADOS PLEO OBJETO CHAVE(NAO POSSUEM POSICAO)
* ACESSO, INSERCAO E REMOCAO DE ELEMENTOS SAO RAPIDOS

- USO COMUMNS: COOKIES, LOCAL STORAGE, QUALQUER MODELO CHAVE-VALOR.

- PRINCIPAIS IMPLEMENTACOES:
* HASHMAP -> MAIS RAPIDO (OPERACOES O(1) EM TABELA HASH) E NAO ORDENADO
* TREEMAP = MAIS LENTO (OPERACOES O(LOG(N)) EM ARVORE RUBR-NEGRA) E ORDENADO PELO VALOR COMPARTETO DO OBJETO(OU COMPARATOR)
* LINKEDHASHMAP -> VELOCIDADE INTERMADIARAIS E ELEMENTOS NA ORDEM QUE SAO ADD

OBS1: CHAVE E VALORES PODEM SER DE QUALQUER TIPO 
OBS2: SEMELHANTE AO SET

ALGUNS METODOS IMPORTANTES:
- PUT(KEY, VALUE), REMOVE(KEY), CONSTAINSKEY(KEY), GET(KEY) -> OPERACOES PARA INSERIR ELEMENTO EM UMA CHAVE, REMOVE CHAVE, CONSTAINS KEY VERIRIFA SE EXIETE A CHEVE, GET PEGA O ELEMENTO DA CHAVE
* BASEADO EM EQUALS E HASH CODE
* SE EQUALS E HASHS CODE NAO EXISTIR E USADA COMPARACAO DE PONTEIROS(POSICAO MEMORIA)

- CLEAR() -> LIMPA O MAP
- SIZE() -> RETORNA O TAMANHO MAP
- KEYSET() -> RETORNA UM SET<K>, K SAO AS CHAVES CONTIDAS NO MAP
- VALUES() -> RETORNA UMA COLLECTION <V>, COLECAO DE UMA CHAVE

OBS1: NO PUT, SEMPRE O VALOR DA ESQUEDA E REFERENTE A CHAVE E O DA DIREITA O VALOR DAQUELA CHAVE, POR EXMEPLO EMAIL, EXEMPLO@EXEMPLO.COM
OBS2: SE UMA CHAVE NAO EXISTE, O METODO GET RETORNA NULL
