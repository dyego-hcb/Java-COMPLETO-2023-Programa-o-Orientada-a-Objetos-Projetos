-- RESUMO SEÇÃO 23 - PROJETO: WEB SERVICES COM SPRING BOOT E JPA/HIBERNATE - DO CURSO JAVA COMPLETO 2023 PROGRAMAÇÃO ORIENTADA A OBJETOS + PROJETOS --

NESSE CAPITULO IREMOS DESENVOLVER UM PROJETO WEB SERVICES, ONDE TREMOS ALGUNS OBJETIVOS QUE SAO:
1- CRIAR UM PROJETO SPRING BOOT JAVA
2- IMPLEMENTAR MODELO DE DOMININO(MODELO DE ENTIDADE DO NEGOCIO) MAIS ROBUSTO E APLICADO AO MERCADO REAL
3- ESTRUTURAR CAMADAS LOGICAS: RESOURCEM SERVICE, REPOSITORY
4- CONFIGURA BANCO DE DADOS DE TESTE (H2) -> BD EM MEMORIA DO JAVA
5- POVOAR O BANCO DE DADOS
6- CRUD - CREATE, RETRIEVE, UPDATE, DELETE -> OPERACOES DE CADASTRO COMPLETO DE ENTIDADE
7- TRATAMENTO DE EXECOES

ESSE PROJETO E UM PROJETO DE BACK-END, OU SEJA, ELE E A PARTE DO SISTEMA QUE RODA NO SERVIDOR, ONDE GERALMENTE TEMOS UMA APP FRONT-END E ELA IRA CONVERSAR COM O BACK-END, O BACK-END E DIVIDO EM CAMADAS RESOURCE(REST CONTROLLERS -> VAO RECEBER AS REQUISICOES E RESPONDER DE ACORDO COM O COMPORTAMENTO DO SISTEMA), SERVICE E ACESSO A DADOS, E TODAS ESSAS CAMADAS CONVERSAM COM AS ENTIDADES
IREMOS NESSA SECAO APRENDER SOBRE AS FERRAMENTAS:
1- SPRING BOOT -> FRAMEWORK USADO PARA CRIAR A APLICACAO
2- APACHE TOMCAT -> CONTEINER WEB PARA EXECUTAR A APP
3- MAVEN -> GERENCIADOR DE DEPENDENCIAS
4- H2 -> BANCO DE DADOS EM MEMORIA PARA TESTE
5- POSTMAN -> TESTAR REQUISOCOES 
6- HEROKU -> PUBLICAR NA NUVEM
7- POSTGRESQL ->  BD

ABAIXO PASSO A PASSO DO DESENVOLVIMENTO DO PROJETO:

ESSE PROJETO ESTARA NO REPOSITORIO DO GITHUB NO SEGUINTE LINK: https://github.com/zebodexx/workshop-springboot3-jpa

PASSO 1: CRIACAO DO PROJETO:

SPRING INITIALIZR -> PROGRAMA WEB OFICIAL DO SPRING PARA CRIAR PROJETOS DO SPRING BOOT

OBS1: SE O MYSQL SERVER NAO ESTIVER RODANDO NO MACOS BASTA sudo killall mysqld PARA FUNCIONAR, PROVAVEL QUE A PORTA ESTEJA EM USO E POR ALGUM MOTIVO NAO FECHOU
OBS2: ANOTATION FAZ O PROCESASMENTO DE BAIXO DOS PANOS PARA COMPILAR O CODIGO FONTE, MUITO USADO EM APP SPRING BOOT
OBS3: DEVE-SE CLICKAR EM REESTAR PARA EXECUTAR O PROGRAMA, NA JANELA BOOT DASHBORD PARA NAO ENTRAR EM CONFLITO
OBS4: O SPRINGBOOT POR PADRAO INICIAL AO RODAR MOSTRA UMA MSG DE ERRO CASO NAO TENHA NENHUMA EDICAO, ESSA MSG DE ERRO INDICA QUE A APLICACAO ESTA RODANDO POR MAIS QUE PARECA QUE DEU ERRADO

PASSO 2: CRIAR A ENTIDADE USER E CRIAR UM RESOURSE PARA TESTE

OBS1: ESSE RESOURCE PARA TESTE E UM RECURSO WEB CORRESPONDENTE A UMA ENTIDADE, ESSE RECURSO DISPONIBILIZA 2 END-POINS PARA RECUPERAR OS OBJETOS CADASTRADOS E TAMBEM INFORMAR O ID
OBS2: DEVEMOS SEMPRE SEGUIR O CHECK LIST BASICO DE CRIACAO DE ENTIDADES DESCRITO ABAIXO:

BASIC ENTITY CHECK-LIST:
1- BASCI ATRIBUTES
2- ASSOCIATIONS(INSTANTIATE COLLECTIOS)
3- CONSTRUCTORS
4- GETTERS E SETTERS(COLLECTIONS: ONLY GET)
5- HASHCODE E EQUALS
60 SERIALIZABLE

OBS1: DEVE-SE SEGUIR NESSA ORDEM
OBS3: DEVE-SE LEMBRA TAMBEM DE CRIAR OS PACOTES PARA CADA TIPO DE CLASSE, COMO ENTITIES, SERVICES, ETC.
OBS4: HASCOD E EQUALS VAI DEPENDER DA LOGICA DO NEGOCIO PARA SABER QUAIS ATRIBUTOS SAO USADOS PARA DEFINIR DIFERENCAS ENTRE OBJETOS
OBS5: PRECISAMOS UTILIZAR O SERIALIZABLE PARA FAZER OS DADOS TRAFEGAREM NA NET

O RECURSO(REST) SERVE PARA CONVERSAR COM A APLICACAO E O BACK-END FAZER AS SOLICITACAO ATRAVES DOS PROTOCOLOS WEB http, COMO POR EXEMPLO RETORNAR TODOS OS USUARIOS DO BD
PARA ISSO, DEVEMOS UTILIZAR A ANNOTATION:
@RESTCONTROLER -> DEFINE QUE SERA UM CONTROLLER  
@REQUESTMAPPING(VALUE = "/NOME_ROTA") -> DEFINE O NOME DO RECURSO

APOS FEITO ISSO, DEVEMOS RETORNAT UM RESPONSEENTITY<T> ONDE T DEVE SER UM TIPO GENERICO QUE SERA DEFINIDO NA SUA LOGICA, APOS FEITO ISSO, ESSE TIPO DE RETORNO E UMA RESPOSTA DO SERVIDOR
OBS1: RESPONSEENTITY E UM END-POINT PARA ACESASR ALGUM OBJETO, E UM TIPO ESPECIFIDO DO SPTRING PARA RETORNAR RESPOSTA WEB

PARA RETORNAR UM RESPONSEENTITY DEVEMOS UTILIZAR O METODO OK().BODY() PARA MOSTRAR PARA O USUARIO, REQUISAO DO TIPO GET DEVE-SE USAR O GETMAPING
OBS1: REQUEISICOES DO TIPO GET RETORNA ALGUMA COISA PARA O USUARIO

PASSO 3: CONFIGURA BANCO DE DADOS DE TESTE H2, CRIAR PROFILE TESTE, JPA
BD H2 -> SAO BD CONFIGURADOS EM MEMORIA, MUITO USADO EM JAVA, NAO PRECISA INSTALAR NADA JA VEM INTEGRADO NO PROJETO
TEST PROFILE -> CRIAR UM PERFIL DE TESTE NO BD PARA FAZER APENAS TESTE
OBS1: PODEMOS TER OUTROS PERFIS, COMO DE DESENVOLVIMENTO, PRODUCAO, ETC

CHECK-LIST:
1- JPA E H2 DEPENDECE -> CONVERTE OO PARA RELACIONAL E VICE VERSA
2- APPLICATION.PROPERTIES -> FICA NA PASTA SRC/MAIN/RESOURCE
3- APPLICATION-TEST.PROPERTIES
4- ENTITY: JPA MAPING
5- REPOSITORY

PARA CRIARMOS O BD DE TESTE, PRECISAMOS UTILIZAR ALGUAMAS DEPENDENCIAS DO JPA E H2 PARA QUE SEJA POSSIVEL TRADUZER DE OO PARA RELACIONAL E VICE VIERSA, ISSO E ADICIONADO NO ARQUIVO PROM.XML
COMO VIMOS ANTERIORMENTE, O MAVEN CARREGA TODAS AS DEPENDENCIAS DO ARQUIVO PORM.XML

APPLICATION.PROPERTIES -> FICA NA PASTA SRC/MAIN/RESOURCE, DEVE-SE FAZER UMA ALTERACAO NESSE ARQUIVO PARA CONFIGURAR O PERFIL DE TESTE
APOS FAZER A ALTERACAO, DEVEMOS CRIAR O APLICATION TESTE.PROPERTIES, ESSE ARQUIVO CONFIGURA A CONEXAO COM O BD, CRIA UM BD DE TESTE, E CONFIGURA A CONEXAO COM O PERFIL DE TESTE
APOS FEITO ISSO, DEVEMOS FAZER ALGUMAS ALTERACOES NA CLASSE CRIADA, COMO COLOCAR AS ANNOTATION PARA QUE O JPA POSSA SABER O QUE E UMA ENTIDADE NO DB NA APLICACAO OO PARA PODER CONVERTE OS OBJETOS

OBS1: DEVE-SE UTILIZAR A BILBIOTECA DE ESPECIFICACAO DO JPA, POIS PREFERENCIA SEMPRE DA ESPECIFICACAO E NAO DA IMPLMENTACAO
OBS2: NO SPRINGBOOT3 NAO PODEMOS DEFINIR UM NOME DA TABELA COMO USER, POIS DA CONFLINTO POIS USER E RESERVADO DE H2, POR ISSO TEMOS QUE RENOMEAR USANDO A ANNOTATIO @TABLE(NAME="NAME_TABLE")

DEVEMOS SEMPRE DENOTAR O ID COM A ANNOTATION @ID
OBS1: SE ID FOR AUTO-INCREMENT DEVE-SE USAR A ANOTATION @GENERATEVALUE(STRATEGY = GENERATIONTYPE.INTEGER) -> FUNCIONA COM QUASE TODOS

AO CRIAR O BD H2, PODEMOS IR ATRAVES DA ROTA /H2-CONSOLE ENTRAR NO GERENCIADO DE BD H2, DEVEMOS ALTERAR A URL E O USUARIO E SENHA SE NECESSARIO
AO ENTRAR NO GERENCIADOR DO BD H2 PODEMOS EXECUTAR OS COMANDOS COMO SELECT * FROM TABLE E VER QUAIS ATRIBUTOS UMA TABELA TEM, MUITO SEMELHANTE A INTERFACE DO PHPMYADMIN

PASSO 4: JPA REPOSITORY, DEPENDECY INJECTION, DATABASE SEEDING

JPA REPOSITORY -> SPRING DATA JPA SUBFRAMEWORK DO ECOSISTEMA SPRING
DEPENDECY INJECTION -> INJECAO DE DEPENECIA AUTOMATICA FEITA PELO FRAMEWORK
DATABASE SEEDING -> POPULAR AUTOMATICAMENTE O DB

CHECK-LIST:
1- USERREPOSITORY EXTENDS JPAREPOSITORY<USER, LONG>
2- CONFIGURATION CLASS FOR TEST PROFILE
3- @AUTOWIRED USERREPOSITORY
4- INSTANTIATE OBJECTIS IN MEMORY
5- PRESIST OBJECTS

OBS1: COMECAMOS DESENVOLVENDO DE BAIXO PRA CIMA, POIS O CONTROLADOR DEPENDE DO SERVICO, E O SERVICO DEPENDE DO REPOSITORY

PARA CRIAR UM USER REPOSITORY, BASTA EXTENDER O JPAREPOSITORY<TIPO_CLASSE, TIPO_CHAVE> NA CLASSE
OBS1: REPOSITORY SAO INTERFACE, POIS O JPAREPOSITORY E UMA INTERFACE

AO DEFINIR O EXTENS DO JPAREPOSITORY JA ESTA PRONTO, POIS O JPAREPOSITORY JA POSSUI UMA IMPLEMNTACAO PADRAO
CLASSE DE CONGI E UMA CLASSE AUXILIAR QUE IRA FAZER ALGUMAS CONFIGURACOES NA APP

PARA FALAR QUE UMA CLASSE E UMA CLASSE DE CONFIGURACAO DEVEMOS COLOCAR A ANOTACAO @CONFIGURATION
APOS FEITO ISSO, PODEMOS FALAR QUE ESSA CLASSE E UMA CONFIGURACAO ESPECIFICA PARA PERFIL COM O @PROFILE(NOME_PROFILE)

PARA CRIAR UMA DEPENDENCIA NO SPRING BASTA COLOCAR EM CIMA DO ATRIBUTO O ANNOTATION @AUTOWIRED ELE ASSOCIA UMA INSTNCIA NO OBJ DA APP
APOS FEITO ISSO, DEVEMOS IMPLEMENTAR A INTERFACE COMMANLINERUNNER PARA EXECUTAR A APLICACAO, E IMPLEMENTAMOS O METODO RUN QUE VEIO NO CONTRADO DA IMPLEMENTACAO DESTA INTERAFACE
DENTRO DO METODO RUN, PODEMOS INSTANCIAR OS OBJETOS E UTILIZAR O USERREPOSITORY PARA SALVER OS OBJETOS NO BD
UTILIZANDO O COMANDO .SAVE OU SAVEALL(LIST) PASSANDO UMA LISTA DE ELEMENTOS COMO ARGUMENTO

PASSO 5: CAMADA DE SERVICOS E REGISTRO DE COMPONENTES 
REGISTRO DE COMPONENTES EXISTE EM TODO FRAMEWORK QUE FAZ INJECAO DE DEPENDENCIA

CAMADA DE SERVICOS E FEITA PARA IMPLEMENTAR AS REGRAS DE NEGOCIO ALGUMA ORQUESTACAO DE NEGOCIO, ETC, E TAMBEM PARA BOAS PRATICAS

OBS1: NAO NECESARIAMENTE PRECISAMOS DA CAMADA DE SERVICOS E CRIADA PARA BOAS PRATICAS DE PROGRAMCAO E DELEGACAO DE RESPOSABILIDADE
OBS2: CONTROLLERS MAIS INXUTOS, FAZENDO COM QUE DEPENDA DE SERVICOS
OBS3: TEM DESNVANTAGENS, MUITAS OPERACOES EM QUE REPASSA PRO REPOSITORY A CHAMADA DE ALGUMA COISA

O REGISTRO DE COMPONENTE -> QUANDO TEMOS UM OBJETO QUE PODE SER INJETADO PELO MECANISMO DE INJECAO DE DEPENDECIA DO SPRING, A CLASSE DESSE OBJETO DEVE ESTAR REGISTRADA NO INJETOR DE DEPENDENCIA, TODO FRAMEWORK QUE UTILIZAMOS TEM ALGUMA FORMA DE REGISTRAR ALGUM SERVICO ALGUMA CLASSE NO MECANISMO DE GESTAO DE DEPENDENCIA
NESSE CASO A CLASSE DEVE ESTAR REGISTRADO COMO COMPONENTE DO SPRING
PARA REGISTRARMOS UM COMPONENTE DEVEMOS UTILIZAR A ANOTATION @COMPONENTE PARA PODER SER INJETADO AUTOMATICAMENTE COM O AUTOWIRED
ALEM DO @COMPONENTE, TEM ALGUMAS OUTRAS ANNOTATION PARA REGISTRAR, POR EXEMPLO O @REPOSITORY PARA REGISTRAR UM REPOSITORIO E UM @SERVICE PARA UM SERVICO
NAO E NECESSARIO FAZER EM INTERFACES REPOSITORY COLCOAR O @REPOSITORY E OPICIONAL POIS HERA DO JPAREPOSITORY

UTILIZAMOS O POSTMAN PARA TESTAS AS REQUISICOES DESSA API REST
UTILIZAMOS O METODO GET PARA REALIZAR REQUISOCES GET, BASTA PASSAR O URL COMO LOCALHOST:8080/NOME

OBS1: SEMPRE QUE FOR FAZE ALUGM METODO NOVO, DEVE-SE COLOCAR O METODO NO SERVICE E NO RESOURCE

TEMOS A CLASSE OPTIONAL<T> ONDE IREMOS INTANCIAR UMA RESPOSTA DA REQUISICAO, POR EXEMPLO FIND BY ID, A FUNCAO GET DO OPTIONAL RETORNA O OBETO DA CLASSE

NAS REQUISOCES GET E POSSIVEL RECEBER O PARAMETOR, BASTA COLOCAR O GETMAPING(VALUE = "/CAMINHO/{NOME_VAR}")
APOS FEITO ISSO, NA HORA DE DECLARA A FUNCAO, DEVEMOS COLOCAR A NOTACAO @PATHVARIABLE PARA QUE O SPRING BOOT ENTENDA QUE ESSE PARAMETRO VAI SER PASSADO NO MOENTO DA REQUISAO

OBS1: POR PADRAO, DA UMA EXECAO 500 QUANDO NAO ENCONTRA ALGUM ID, ESSA NAO E A FORMA CORRETA DE RETORNA UM ERRO, A FORMA CORRETA SERA TRATADA MAIS A FRENTE.

PASSO 6: ENTIDADE PEDIDO, INSTANT E ISO 8601
OBS1: ISTANT E USADO DEPOIS DA VERSAO 8, VERSAO 8 ABAIXO USA O DATE

DEVEMOS IMPLEMENTA O RELACIONAMENTO ENTRE AS CLASSES PARA QUE O JPA TRANSFORMAR EM CHAVE ESTRANGEIRAS NO BD
UTILIZAMOS A ANOTACAO @MANYTOONE QUE E MUITOS PARA 1, DEVE-SE COLOCAR O @JOINCOLUMN(NAME = "NOME_VAR")
UTILIZAMOS A ANOTACAO @ONETOMANY(MAPPEDBY = "NOME_VARIAVEL_DO_OUTRO_LADO") NO CASO DE OO 

OBS1: DEVE-SE DAR OUTRO NOME PARA ORDER, POIS DA CONFLITO

POREM AO REALIZAR ASSOCIACAO AO RELIZAR REQUISOCOES GET, FICA EM LOOP, PARA RESOLVER ISSO DEVEMOS COLOCAR EM UM DOS LADOS DA ASSOCIACAO A ANOTACAO @JSONIGONRE

QUANDO TEMOS UMA ASSOCIACAO MUITOS APRA UM, AO INSTANCIAR UMA ASSOCIACAO DE MUITOS, O JPA AUTOMATICAMENTE INSTANCIA A ASSOCIACAO DE UM DO MUITOS
POREM NAO ACONTECE PARA ASSOCIACAO UM PARA MUITOS
OCORRENDO O LAZY LOADING, CARREGA QUANDO NECESSARIO

PODEMOS CRIAR PADROES DE DATA, COMO O DO IS 8601 UTILIZANDO A ANOTACAO @JSONFORMAT(SHAPE = JSONFORMAT.SHAPE.STRING, PATTERN = "DATA_MODEL", TIMEZOME = "GMT")

OBS1: SE TIVER O @JSONIGONRE IGNORA NA CLASSE AO MOSTRAAR
OBS2: OPENVIEW = TRUE REALIZA ESSA BUSCA E INSTANCIACAO DO BD PARA OO QUE MOSTRA O USUARIO
OBS3: CASO ESTEJA FALSE, DA ERRO 500 DE QUE NAO E POSSIVEL CHAME O BD PARA MOSTRA O RETANTE
OBS4: TEM VANTAGENS MAIS PRATICO, POREM COMPLICA O CICLO DE VIDA

PASSO 7: ORDERSTATUS ENUM

NA PARTE DE CRAICAO DAS CLASSES ENUM, NAO PODEMOS CRIAR DO JEITO PADRAO POIS ISSO IRA GERAR UM GRANDE CUSTO DE MUDANCA, POIS PODE VIR ALGUM PROGRAMADOR DESAVISADO E MUDAR A ORDEM LA, VISTO QUE LA NO ENUMS PADRAO, A ORDE E DE 0 A N ATRIBUTOS, SE COLUCAR UM NO MEIO, MUDA TODA A ORDEM DOS DEMAIS A FRENTE, PORTANTO QUANDO USA APLICACOES DE BD O JEITO DE CRIAR ENUMS E DIFERENTE
PARA CRIAR ENUMS PARA UTILIZAR EM BDS, DEVEMOS ATRIBUIR MANUALMENTE UM VALOR PARA O TIPO ENUMERADO ATRAVES DO (NUM)
POREM O JAVA EXIGE QUE IMPLEMENTE OUTRAS COISAS, TAIS COMO: CRICACO DE CONSTRUTOR, CRIACAO DE METODO GET E UMA FUNCAO QUE RETORNA QUAL O ENUM DE ACORDO COM UM INTEIRO PASSADO POR PARAMETRO, CASO NAO HAJA DEVE-SE TRATAR A EXECAO E MOSTRAR UMA MSG

PASSO 8: ENTIDADE CATEGORY

PASSO 9: ENTIDADE PRODUCT
NESSA ETAPA NAO USAMOS LIST, USAREMOS SET, QUE E UM CONJUNTO, POIS PODEMOS TER MAIS DE UM PRODUTO DA MESMA CATEGORIA, MAS NAO PODEMOS TER O MESMO PRODUTO EM MAIS DE UMA CATEGORIA
OBS1: TODA VEZ QUE INSTANCIAR UMA ASSOCIACAI DEVE-SE INSTANCIARA NO MOMENTO DA CRIACAO DO OBJETO PARA QUE NAO COMECE NULA, COMECE VAIZA E INSTANCIADA

EM CONSTRUTURES JAMAIS COLOCAMOS COLECOES, POIS A MESMA JA E INSTANCIADA ANTES DO CONSTRUTOR
NO MOEMENTO DEU UM ERRO DE RELACIONAMENTO DOS SET QUE CRIAMOS NA CLASSE, UMA SOLUCAO PROVISORIA PARA ISSO E UTILIZAR A ANOTACAO @TRANSIENTE IMPEDE QUE O JPA INTERPRETE ISSO

PASSO 10: MANY-TO-MANY ASSOCIATIO WITH JOINTABLE
EM JAVA, ESCOLHEMOS UMA DAS CLASSE, AO ESCOLHE UMA DAS CLASSES, TIRAMOS O @TRANSIENTE DELA, E TEREMOS QUE FAZER O MAPEAMENTO PARA TRANSFORMAR A ASSOCIACAO DOS OBJETOS NA TABELA DO BD
UTILIZA-SE O @MANYTOMANY
E O @JOINTABLE(NAME = NAME_TABE, JOINCLOMUNS = @JOINCOLMUN(NAME = "NOME_CHAVE"), INVERSEJOINCLOMUNS = @JOINCOLMUN(NAME = "NOME_CHAVE"))

OBS1: O JOIN TABLE INDICA O NOME DA TABELA, E QUAIS AS CHAVES ESTRANGEIRAS QUE SAO ASSOCIADA
OBS2: NAME -> NOME DA TABELA
OBS3: JOINCOLUNM -> NOME DA CHAVE ESTRANGEIRA NO BD
OBS3: INVERSEJOINCLOMUNS -> NOME DA TABELA EM QUE A CHAVE ESTRANGEIRA FAZ REFERENCIA DA OUTRA ENTIDADE

COM ISSO, NA OUTRA CLASSE ASSOCIDADA BASTA USAR A ANOTACAO @MANYTOMANY(MAPPEDBY = "NOME_VAR")

OBS1: NO JPA TODAVEZ QUE FOR SALVAR UM OBJETO, DEVE-SE USAR O REPOSITORY.SAVEALL OU SAVE

PASSO 11: ORDERITEM, MANY-TO-MANY ASSOCIATION WITH EXTRA ATTRIBUITES
EM OO, DEVEMOS CRIAR UMA CLASSE AUXILIAR QUE IRA ARMAZENAR A LIGACAO ENTRE AS DUAS OUTRAS CLASSES/TABELAS

OBS1: NESSES CASOS SEMPRE COLUCAR NO ENTITIES.PK

NESSA CLASSE PK, NAO TEMOS CONSTRUTUROES APENAS OS METODOS GET E SET E HASHCODE EQUAL
QUANDO E UMA CLASSE PK, NAO UTILIZAMOS A ANOTACAO @ENTITY, UTILIZAMOS A @EMBEDDABLE 
E NA CLASSE QUE IRA TER UMA ASSOCIACAO COM A CLASSE PK, DEVE-SE INSTANCIAR OS OBJETOS NOS CONSTRUTORES E ATRAVES DOS SET DEFINIR QUAL OBJETO FOI ASSOCIADO
NA CLASSE QUE TEM A ASSOIACAO COM A CLASSE PK, NAO USA O @ID USA-SE O @EMBBEDID

APOS FEITO ESSA ALTERACAO, EM UMA DAS CLASSES EM QUE FAZ ASSOCIACAO, NESSE CASO NA ORDER, DEVEMOS CRIAR UM CONJUNTO DE ORDEITEMS COM RELACAO UM PARA MUITOS, MAPEADOS PELO ID.ORDER POIS CRIAMOS UMA CLASSE PK ID E O OBJETO DA CLASSE PK CRIADA
OBS1: QUANDO FOR CRIAR A ASSOACIACAO DA CLASSE PK COM A CLSSE DE RELACIONAMENTO, DEVE-SE INICIAR O OBJETO
OBS2: TODA VEZ QUE TIVE REQUISICAO EM QUE TEM OBJETOS ASSOCIADOS DEVE-SE COLOCAR JSONIGNORE EM UMA DAS PARTES

PARA ESSAS CLASSES QUE REPRESENTAM O RELACIONAMENTO NAO TEM OS RECURSOS E SERVICES

PASSO 12: PRODCUT-ORDER-ITEM ONE-TO-MANY ASSOCIATION
DEVE-SE UTILIZAR SEMPRE O SET PARA QUE NAO HAJA DUPLICACAO

PASSO 13: PAYMENT, ONE-TO-ONE ASSOCIATIN
PARA FAZER O MAPEAMENTO DE UM PARA UM, DEVEMOS IR NA CLASSE DEPENTE E COLOCAR A ANOTACAO @ONETOONE E @MAPSID
NA OUTRA CLASSE DEVEMOS COLOCAR TABEME A ANOTACAO @ONETOONE(MAPPEDBY = "NOME_ASSOCIACO", CASCADE = CASCADETYPE.ALL)
OBS1:  DEVEMOS MAPEAR PARA QUE AMBAS TENHAM O MESMO ID, COM O CASCADETYPE=ALL ASSOCIACAO 1 PARA 1 E OBRIGATORIO
PARA SALVAR O OBJETO DEPENDENTE DE UMA RELACAO 1 PARA 1 NAO CHAMAMOS O REPOSITORIO DO PROPRIO OBJETO, FAZEMOS A ASSOCIACAO DE MAO DUPLA EM MEMORIA, ONDE SALVAMOS NO REPOSITORIO DO OBJETO EM QUE A RELACAO E COMPOSTO, POR EXEMPLO O PAGAMENTO E SALVO NO REPOSITORIO DO PEDIDO

PASSO 14: SUBTOTAL E TOTAL METHDOS

OBS1: JAVA EE DEVEMOS COLOCAR OS METODOS COMO GET

PASSO 15: USER INSERT

QUANDO VAMOS RECUPERAR DADOS DO BD USAMOS O METODO GET
PARA INSERIR DADOS USAMOS O METODO POST COM A ANOTACAO @POSTMAPING, POREM AO FAZE ISSO, NOS PAREMETRO TEMOS QUE UITLIZAR A ANOTACAO @REQUESTBODY
AMBOS DO HTTP

O @REQUESTBODY -> PEGA OS DADOS DO BODY DO JSON 

QUANDO CONSEGUIMOS INSERIR UM RECURSO E MAIS ADEQUADO VOLTAR O CODIGO DE RESPOSTA 201 EE NAO 200, O 201 E UM CODIGO HTTP QUE FALA QUE REALEMENTE CRIOU UM RECURSO
PARA ISO USAMOS O .CREATED(URO_LOCATION)
O URI_LOCATION E UM CACECALHO COM O ENDERECO DO RECURSO CONFIGURADOS
NO SPRINGBOOT E FACIL CRIAR ESSE ENDERECO, BASTA INSTANCIAR UM OBJETO URI, SERVLETURICOMPONENTSBUILDER.FROMCURRENTREQUEST().PATH("/{ID}").BUILDANDEXPAND(OBJ.GETID()).TOURI().

COM ISSO, PODEMOS RETORNAR UM CREATED(URI).BODY(OBJ)

OBS1: DEVE-SE EPSECIFICAR BEM A SAIDA DA REQUISICAO, COMO NO EXEMPLO A RESPOSTA DE 200 ESTARIA CORRETA PARA A CRIACAO DE OBJETOS, POREM TEMOS UMA ESPECIFICA PARA ISSO, QUE A RESPOSTA 201, COM ISSO TEMOS QUE DEIXA BEM DEFINIDAS AS RESPOSTAS VISANDO BOAS PRATICAS DE PROMGRAMACAO, CADA UMA ESPECIFICAMENTE COM SEU CODIGO DE RETORNO

PASSO 16: USER DELETE
USAMOS A FUNCAO DELETEBYID
PARA DELECAO USAMOS A ANOTACAO @DELETEMAPPING(VALUE = "/{ID}")
NA CAMADA DE RECURSO, DEVEMOS COLOCAR O TIPO GENERICO VOID, POIS NAO RETORNA NADA
SEMELHANTE AO DE BUSCA, DEVEMOS COLOCAR O @PATHVARIABLE NO PARMETRO DA FUNCAO
PARA RETORNAR NADA, USAMOS A FUNCAO NOCONTENT

QUANDO TEMOS OJBETOS ASSOCIADOS NO BD ENTRE AS TABELAS, NAO PODEMOS DEELTAR DEVIDO A ASSOCIACAO DOS ELEMENTOS, DA UM ERRO, MAS PODE SER TRATADO

PASSO 17: UPDATE USER
PARA ATUALIZAMOS UM OJBETO NO BD, PRECISAMOS DO ID E UM OBJETO NO QUAL TEM AS ALTERACOES, APOS ISSO PASSADO POR PAREMETRO, DEVEMOS CRIAR UM OBJETO ENTIDADE QUE VAI SER MONITORADO
UTILIZA-SE O GETREFERNECEBYID PARA PEGAR DADOS DO OBJETO, ELE PEGA OS DADOS DO BD QUANDO NECESSARIO, MAIS EFICIENTE
PARA ATUALIZAR OS DADOS NO BD, UTILIZAMOS A ANOTACAO @PUTMAPPING(VALUE = "/{ID}")

PASSO 18: TRATAMENTO DE EXECOES
IREMOS REALIZAR ALGUNS TRATAMENTOS DE EXECAO, COMO:

1- DO METODO FINDBYID -> POIS DA ERRO DO CODIGO 500, POREM O CODIGO CORRETO E 404 DE ALGO NAO ENCONTRADO DEVE-SE COLOCAR OS CODIGOS CORRETOS
2- DO METODO DELETE -> POIS PODE DAR ERRO QUANDO NAO ENCONTRA UM USUARIO, NOVAMENTE DA O ERRO 500, O ERRO ESTA ERRADO O CODIGO DEVERIDA SER 404 DE NAO ENCONTRADO
3- DO METODO UPDATE -> VERIFICAR SE ENCONTRA UM USUARIO QUE EXISTE OU NAO, CASO NAO EXISTA FALZAR A MENSGAEM

DEVEMOS FAZER ESSA EXECOES QUE DAQUELA CAMADA DE SERVICO E NAO DEIXA ESTORA EXECOES DIVERSAS
PARA ISSO, CRIAMOS 3 CLASSE, 1 CLASSE QUE DA O ERRO NO SERVICO, POR EXEMPLO DE NAO ENCONTRAR UM OBJETO NO BD
DEPOIS TEMOS UMA CLASSE QUE IRA SE COMPORTAR COMO O PADRAO DA MSG DE ERRO, MOSTRANDO O STATUS, MSG, O ERRO, ETC.
DEPOIS TEMOS QUE CRIAR UMA EXECAO DE HANDLER, QUE E TEM QUE COLOCAR A ANOTACA @CONTROLEADVICE PARA QUE ESSA CLASSE CONSIGA CAPTAR AS EXECOES QUE OCORREM PARA QUE ESSE OBJETO POSSA EXECUTA ALGUM POSSIVEL TRATAMENTO.
COM ISSO, DEVEMOS CRIAR UMA FUNCAO NA CLASSE HANDLER QUE IRA CAPTAR AQUELA EXECAO ESPECIFICA, COMO POR EXEMPLO DE NAO ENCONTRAR ALGUM USARIO NO BD, COM ISSO DEVEMOS UTIIZA A ANOTACAO @EXCPETIONHANDLER(NOME_CLASE_EXECAO.CLASS)

PARA RETORNA UMA EXECAO QUE FOI CRIADA, CEVEMOS UTILIZAR O .STATUS(STATUS).BODY(ERR)

QUANDO TEMOS QUE TRATAR AS EXECOES, PODEMOS UTILIZAR O METODO ORELSETRHWO(LAMBDA) E PASSA UMA EXPRESSAO LABMDIA () -> NEW NOME_CLASSE_EXECAO(ID)
PARA REAPROVEITAR  UMEA EXECAO CRIADA, DEVEMOS PRIMEIRAMENTE DESCOBRIR QUAL POSSIVEL EXECAO QUE OCORREU NAQUELE MOMENTO, E TRATA-LA E DEPOIS LANCAR A EXECAO CRIADA
NOS CASOS DE DELECAO, TEMOS QUE TRATAR A EXECAO DO PROPIO SPRINGBOOT, ONDE NAO PODEMOS DELETAR OBJETOS ASSOCIADOS, PARA ISSO UTILIZAMOS A EXECAO DATAINTEGRITYVIOLATION, E PARA ESSA EXECAO DEVEMOS CRIAR UMA EXECAO PERSONALIZADA PARA MOSTRAR UMA MSG MAIS DIRETA AO USUARIO DO QUE FOI A CAUSA DAQUELE ERRO


PASSO 19: HEROKU:
IMPLANTACAO DA APP NA PLATAFORMA HEROKU PAGO, ESSE PASSO SERA APENAS PARA CONHECIMENTO POR ENQUANTO

PARA CRIAR UMA APILICACO NO HEROKU, BASTA CADASTRAR O CARTAO PARA COMPRAR HOSPEDAGEM, E IR EM CRIRAR APP
LA VOCE DEFINE O NOME DA SUA APP E QUAL REGIAO

DEVEMOS TAMBEM PROVISIONAR O POSTGRESQL
INDO EM RESOURCE E PESQUISAR POSTEGREE E SELECIONAR O HERUKO POSTGRES, COM ISSO ASSOCIAMOS UMA INSTANCIA DO POSTGRESQL OU QUALQUER BD A APP CRIADA

PARA INSTALAR O POSTGRE NA MAQUINA, BASTA BASTA IR NO SITE OFICIAL DO POSTGRESQL

APOS ISSO, DEVEMOS CRIAR O PROFILE DEV NA APLICACAO, VISTO QUE ESTAVAMOS MECHENDO APENAS NO PROFILE DE TESTE
PARA ISSO, DEVEMOS ADICIONAR A DEPENDENCIA DO BD NO MAVEN
APOS FEITO ISSO, DEVEMOS CRIAR UM ARQUIVO QUE CONTEM AS PROPRIEDADS DE CONEXAO COM O PERFIL DEV NO BD CRIADO
ONDE NESSE ARQUIVO DE PROPEIDADES TEMOS A URL DE CONEXAO COM O BANCO, O USUARIO, SENHA, PROPRIEDADES DO JPA

PARA PEGAR O SCRIPT LOCAL DO POSTGRSQL, DEVEMOS FAZER N SEGUINITE PASSO A PASSO:
1- SELECIONAR O DB
2- SELECIONAR FERRAMENTAS -> BACKUP
3- FORMAT: PLAIN, ECODING UTF-8, DUMP OPTIONS: ONLYE SCHEMAS YES(APENAS AS TABELAS, NAO RECUPERA DADOS), BLOOBS: NO (BLOBS E PRA TIPO DE IMAGEM), DO NOT SAVE (ALL), VERBOSE MESSAGES NO

DEVEMOS FAZER O BACKUP DO SCPRITP DE FORMA MAIS GENERICA POSSIVEL PARA NAO HAVER CONFLITO COM O SERVIDOR

PARA RODAR O SCRIPT SQL CONECTA O BD LOCA NO BD HEROKU, DEVEMOS IR EM CONFIGURACOES -> CONFIG VARS E PEGAR A STRING DE CONEXAO COM O BD
E COM ISSO, TEMOS TODOS OS DADOS QUE SERAO UTILIZADOS PARA REALIZAR A CONEXAO COM O BD LOCAL QUE APONTARA PARA O BD REMOTO 

PARA LISTAR APENAS A SUA BD DEVEMOS COLOCAR UMA RESTRICAO

APOS ISSO, PODEMOS UTILIZAR O BACKUP QUE FIZEMOS DAS CRIACOES DAS TABELAS, COM ISSO, NO BD REMOTO VAI TER AS TABELAS QUE TEMOS NO BD LOCAL ONDE USAMOS DE CASOS DE TESTE

PARA INSTALAR O HEROKU CLI, BASTA PESQUISAR HEROKU CLI, APOS INSTALR O HEROKU CLI TEMOS QUE FAZER O LOGIN, UTILIZANDO OS SEGUINTES COMANDOS:

heroku login -> CASO ESSE NAO FUNCIONAR USA O ABAIXO
winpty heroku.cmd login

APOS FEITO ISSO, DEVEMOS FAZER UM DEPLOY DA APLICACAO NO HEROKU, OARA ISSO TEMOS QUE FAZER O SEGUINTE:
IR EM DEPLPOY NO HEROKU, E TEMOS AS INFORMACOES DE COMO DAR O DEPLOY

OBS1: DEVEMOS UTILIZAR O DEPLOY BASEADO NO GIT, O HEROKU RECEBE ESSE PUSH E AUTOMATICAMENT O HEROKU RECEBE O PUSH FAZ O BUILD DA APP E IMPLANTAR

APOS FEITO ISSO, TEMOS QUE CONFIGURAS AS VARIAVEIS NO HEROKU
CASO USA TOKEN DE AUTENTICACAO DEVE-SE COLCOA-LAS E COLOCAR O TEMPO

APOS FEITO ISSO, DEVEMOS CRIAR UM PROPEITES DA APLICACAO, ESSE PROPETIS REFERE-SE A PROPEIDADES DA APLICACAO EXECUTANDO EM AMBIENTE DE PRODUCAO

APOS FEITO ISSO, DEVEMOS CRIAR UM ARQUIVO CHAMADO, SYSTEM.PROPEITES, ONDE VAMOS AVISA O SERVIDOR QUAL VERSAO DO JAVA USAMOS

PARA DAR UM COMMIT NO HEROKU USANDO O GIT, BASTA SEGUIR O PASSO A PASSO NORMAL, POREM NO PUSH COLOCAMOS HEROKU MASTER

APOS FEITO ISSO, O HEROKU JA COMPLIA E BUILDA O APP, E RETORNA O ENDERECO DA APP
COM O ENDERECO DA APP VOCE CONSEGUE ACESSAR A MESMA E REALIZAR TESTES NO POSTMAN IGUAL ESTAVAMOS FAZENDO ANTES SO QUE COM O URL DO PROJETO NO REPOSITORIO DO HEROKU