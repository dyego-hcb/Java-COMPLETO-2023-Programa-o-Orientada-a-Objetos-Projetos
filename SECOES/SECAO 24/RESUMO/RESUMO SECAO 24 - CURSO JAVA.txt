-- RESUMO SEÇÃO 24 - PROJETO: API-RESTFULL COM SPRING BOOT E BANCO MONGODB(WEBSERVICES + NOSQL) - DO CURSO JAVA COMPLETO 2023 PROGRAMAÇÃO ORIENTADA A OBJETOS + PROJETOS --

PARA ESSE PROJETO PRECISAMOS DAS FERRAMETAS STS E O POSTMAN
FEITO ISSO, DEVEMOS INSTALAR O MONGO DB NO SISTEMA, CADA SO TEM SEU JEITO DE INSTALAR POREM MELHOR JEITO E SEGUINDO A DOCUMENTACAO NO SITE DA MONGODB

EM MACOS AO INSTALAR VIA HOMEBREW, DEVE-SE UTILZIAR O SEGUINTE COMANDO PARA EXECUTAR O MONGODB brew services start mongodb-community@7.0
E PARA PARA DE EXECUTAR O MONGDB USAMOS O SEGUINTE COMANDO brew services stop mongodb-community@7.0

EM BANCO DE DADOS ORIENTADOS A DOCUMENTOS EM VEZ DE TRATARMOS COMO TABELAS, TRATAMOS COMO COLECAO

PROBLEMA 01 -> INCOMPATIBILIDADE DE IMPEDANCIA: QUANDO TEMOS UM MODELO RELACIONAL, CADA UMA DAS ENTIDADES E REPRESENTADO POR TABELA, CADA UM DOS DADOS ESTA ARMAZENADO POR UMA TABELA QUANDO TEMOS ALGUMA TABELA COMPOSTA POR OUTROS ATRIBUTOS VINDO DE OUTRAS TABELAS, PARA BUSCAR ESSES VALORES, DEVEMOS IR EM CADA UMA DAS TABELAS E BUSCAR OS DADOS, A INCOMPATIBILIDADE DE IMPEDANCIA E O PROBLEMA QUE TEMOS, QUE OS DADOS QUE ESTAO ARMAZENADOS EM MEMORIA SECUNDARIAS, QUE ESTAO NA FORMA DE TABELAS ELES ESTAO ARMAZENADOS DE UMA FORMA DIFERENTE DAQUELES DADOS EM MEMORIA DO COMPUTADOR QUANDO O PROGRAMA ESTA EXECUTANDO, NA MEMORIA DO COMPUTADOR ELES VAO ESTAR REPRESENTADOS POR OBJETOS RELACIONADOS, FAZENDO COM QUE TENHA QUE FICAR TRADUZINDO DE MODELO RELACIONAL PARA MODELOS ASSOCIADOS A MEMORIA
PARA SOLUCIONAR ESSE PROBLEMA, SURGIRAM AS FERRAMENTAS ORM QUE SAO MAPEAMENTO OBJETO RELACIONAL PARA FACILITAR A VIDA DE PROGRAMADORES

OBS1: O USO DE ORM TEM PROBLEMAS DE PERFORMACE

COM OU SEM ORM TRANSACOES E JUNCOES DEGRADAM PERFORMACE, POREM NAO TEMOS COMO CORRER MUITO DE TRANSACOES, POIS HA OPERACOES QUE DEVEM GARANTIR SEGURANCA
JUNCOES E UMA OPERACO PESADA, COM COMPLEXIDADE ALTA

PROBLEMA 02 -> GRANDE VOLUME DE DADOS E ACESSOS: SOLUCAO UTILIZAR ESCALAS VERTICAS(PC MAIOR E POTENTE) OU HORIZONTAIS(ADOTAR UMA ESTRUTRA DE CLUSTER OU GRID COM VARIOS PC MENTORES)

CLUSTER OU GRID DE FORMA GERAL E MAIS INTERESANTE, POIS O PC MAIOR E PONTENTE E MAIS CARO, COM ISSO TEMOS ALGUMAS VANTAGENS:
CUSTO -> MAIS BARATO O CLUSTER DO QUE UM SUPER PC
RESILIENCIA -> SE UM PC PARA DE FUNCIONAR TEM OUTROS FUNCIONANDO, NAO INTERFERE GERANDO ALTA CONFIABILIDADE
CRESCIMENTO MENOS LIMITADO -> EXISTEM LIMITES DE PROCESSADOR, QUANDO TEM CLUSTER ESSE PROBLEMA E MENOR, POIS PODE AUMENTAR O CLUSTER
VIRTUALIZACA -> UTILZAR MAQUINA VIRTUAL 

PARA GRANDE VOLUMES DE DADOS E ACESSOS, PROVAVELMENTE DEVE-SE UTILIZAR OS CLUSTER POR SER FLEXIVEIS

POREM BD RELACIONAIS NAO SAO FEITOS PARA EXECUTAR BEM EM CLUSTER, POREM HA ALTERNATIVAS DE DISTRIBUICAO E REPLICACAO DO BD RELACIONAL, POREM E MUITO CUSTOSO
COM ISSO SURGIRAM O NOSQL

NOSQL:


PRIMEIRAS INFLUENCIAS -> GOOGLE(BIGTABLE) E AMAZON(DYNAMO), ESSAS EMPRESAS PUBLICARAM ARTIGOS SOBRE AS SOLUCOES QUE ELAS ESTAVAS UTILIZANDOS, ESSES ARTIGOS FORAM INFLUENTES PARA CIRAR OS DB NOSQL
O NOME NOSQL E ACIDENTAL

CARACTERISTICAS COMUNS:
- NAO UTILIZAM MODELOS RELACIONAIS
- TEM UMA BOA EXECUCAO EM CLUSTERS
- CODIGO ABERTO
- APARECERAM NO SECULO XXI
- NAO TEM ESQUEMA

OBS1: POSTGRES E ORACLE NAO SAO NOSQL

DUAS CLASSE PRINCIPAIS DE BANCO DE DADOS:

1- BD ORIENTADO A AGREDADOS: (MAIS COMUM)
- MODELO CHAVE-VALOR(RIAK, REDIS)
- MODELO DE DOCUMENTOS(MONGODB, COUCHDB)
- MODELO FAMILIA DE COLUNAS(CASSANDRA, APACHE HBASE)

OBS1: TERMO AGREDOS SE REFERE A UM CONJUNTO DE OBJ RELACIONADOS TRATADOS COMO UMA UNIDADE

2- BD DE GRAFOS(NEO4J) 
- UTEIS DADOS COM RELACIONAMENTOS COMPLEXOS, PONTO FRACO DO BD ORIENTADO A AGREGADOS

AGREGADO E UM CONJUNTO DE OBJETOS RELACIONADOS QUE DESEJAMOS TRATAR COMO UMA UNIDADE, ARMAZENADO NA FORMA DE UM BLOCO UNICO LUGAR NO BD

COM UM UNICO ACESSO RECUPERA RAPIDA A INFORMACAO
OS DADOS NAO SAO NORMALIZADOS, PODENDO REPETIR ALGUNS DADOS PARA QUE ESTEJAM TUDO EM UMA UNICA UNIDADE
OBS1: DADOS FREQUENTEMENTE ACESSADOS JUNTOS > NORMALIZACAO

HA SITUACOES QUE NO LUGAR DE REPETIR DADOS, REFERENCIA-SE OUTRO DADO QUE ESTA EM OUTRO LUGAR,  E DETERMINADO PELA NECESSIADE DO NEGOCIO, OU COLOCA UM OUTRO OBJETO ALINHADO AO AGREDADO OU REFERENCIA, SE FOR REFERENCIA TEM QUE IR NO BD E RECUPERA A INFORMACAO

PORQUE O USO DE AGREGADOS: POIS ELES JA POSSUIEM A ESTRUTURA DE OBJETOS ASSOCIADOS EM MEMORIA RAM, E UMA UNIDADE NATURAL DE REPLICACAO E FRAMENTACAO(TODOS OS DADOS DE UM AGREGADO ESTAO ARMAZENADOS JUNTOS E NO MESMO NODO DA CLUSTER, SE PRECISAR DE UM AGREGADO E ACESSAR EM UM NODO DO CLUSTER TODOS OS DADOS DO AGREGADO QUE PRECISAR ESTARAO NAQUELE NODO)
OBS1: NAO SUPORTAM TODO SUPORTE ACID COMO BD RELACIONAIS, POREM EXISTEM MECANISMO PARA TRATAR CONCISTENCIA DE DADOS, MAS GARANTEM ATOMICIDADE NO AGREGADO SE VAI SER TOTALEMENTE OU NAO

IREMOS ABAIXO DESENVOLVER UM PROJETO DE UMA APIRESTFULL COM SPRINGBOOT E MONGODB, ABAIXO O PASSO A PASSO PARA O DESENVOLVIMENTO:

O PROJETO DESENVOLVIDO ESTA NO SEGUINTE REPOSITORIO NO GITHUB: https://github.com/zebodexx/workshop-springboot3-mongodb

PASSO 1 - PRIMEIRO COMMIT DO PROJETO: CIRANDO O PROJETO NO STS E O REPOSITIO E REALIZANDO O PRIMEIRO COMMIT
OBS1: PODEMOS ALTERAR A PORTA DO STS UTILIZANDO O COMANDO SERVER.PORT=${PORT:NUM_PORTA} NO ARQUIVO APPLICATION.PROPETIES

PASSO 2 - ENTITY USER E REST FUNCIONANDO: CRIAR AS ENTIDADES USUARIOS E VERIFICAR SE O REST TA FUNCIONANDO
NO MONGODB E REPRESENTADO PELA COLECAO USER

CHECKLIST PARA CRIAR AS ENTIDADES:
- ATRIBUTOS BASICOS (ID NOME E EMAIL)
- ASSOCIACAO(INICIA AS COLECOES) (NESSA ETAPA NAO TERA)
- CONSTRUTORES(NAO INCLUA COLECOES NO CONSTRUTOR COMO PARAMETROS)
- GETTERS E SETTERS
- HAHSCODE E EQUALS(IMPLEMENTACAO PADRAO: SOMENTE ID)
- SERIALIZABLE(PADRAO 1L)

CHECKLIST:
- NO SUBPACOTE DOMAIN, CRIAR A CLASSE USER
- NO SUBPACOTE RESOURCE, CRIAR UMA CLASSE USERRESOURCE E IMPLMENTAR NELA O ENDPOIT GET PADRAO

OBS1: DOMAIN REPRESENTA DOMINIO, ONDE ESTARAO AS ENTIDADES DO NEGOCIO
OBS2: RESOURCE POIS E O TERMO TECNICO QUE UTILIZAMOS PARA REFERENCIAR OS RECURSOS REST, SAO RECURSOS QUE O BACKEND VAI DISPONIBLIZAR, DO PONTO DE VISTA DE BACKEND CHAMAOS DE CONTROLADOR POREM E NO POSTO DE VISTA DE IMPLEMENTACAO

AS ANOTACOES ABAIXO REALIZAM O MAPEAMENTO DE UM METODO GET:
@RequestMapping(method = RequestMethod.GET)
@GetMapping

PASSO 3 - CONEXAO AO MONGODB COM REPOSITORY E SERVICE: COMO ESTAMOS ADOTANDO UM PADRAO DE CAMADAS, TEMOS UMA APLICACAO QUE POSSUI UM FRONT-END E UM BACKEND, O BACKEND VAI EXPOR OS CONTROLADORES REST E OS MESMOS ACESSAM OS SERVICOS E OS ERVICOS ACESSAM A CADAMA DE ACESSO A DADOS(REPOSITORY) E TAMBEM TEMOS A CAMADA DE DOMINIO QUE SAO OS OBJETOS QUE REPRESENTAM OS DOMINIOS

CHECLIST:
- EM PORM.XML, INCLUIR A DEPENDECIA DO MONGODB
- NO PACOTE REPOSITORY, CRIA A INTERFACE USERREPOSITORY (ESSA INTERFACE EXETNDS DO MONGOREPOSITORY QUE JA POSSUI O SPRING DATA, QUE PRECISA DE 2 DADOS O TIPO DA CALSSE DE DOMINIO E O TIPO DO ID DA CLASSE)
- EM USERRESOURCE, REFATORAR O CODIGO USANDO USERSERVICE PARA BUSCAR OS USUARIOS
- EM APPLICATION.PROPRIETE DEVEMOS INCLUIR OS DADOS DE CONEXAO COM A BASE DE DADOS COM O SEGUINTE COMANDO: spring.data.mongodb.uri=mongodb://localhost:27017/nome_bd
- SUBIR O MONGODB(COMANDO MONGOD)
- USANDO COMPASS:
* CRIAR BD workshop_MONGO
* CRIAR COLECAO USER
* CRIAR ALGUNS DOCS MANUALMENTE
- TESTAR O ENDPOI /USERS

A TAG @AUTOWIRED FAZ COM QUE O PROPRIO SPRING VAI PROCURAR A DEFINICAO DESSE OBJETO E INTANCIA O OBJETO, TRATA-SE DO MECANISMO DE INJECAO DE DEPENDECIA DO SPRING
O REPOSITORY DO SPRING DATA POSSUI VARIOS METODOS, ENTRE ELES O FINDALL

DIFERENTE DOS BD RELACIONAIS ONDE COLOCAVAMOS A ANOTACAO @ENTITY EM UMA CLASSE QUE SERIA UMA TABELA NO BD, NOS BD DE DOCUMENTOS COMO O MONGO UTILZAMOS A ANOTACAO @DOCUMENT
OBS1: OPICIONAL COLOCAR O PARAMENTRO (COLLECTION="NOME_COLLECTIO") ISSO FAZ COM QUE O BD CRIE A TABELA COM AQUELE NOME, CASO NAO USE, ELE CRIA COM O NOME DA CLASSE
PARA DEFINIR UM ATRIBUTO COMO ID NO BD, BASTA COLOCAR A ANOTACAO @ID

OBS1: SEMELHANTE AO HIBERNATE E O MYSQL DO EXEMPLO PASSADO

PASSO 4 - OPERACAO DE INSTANCIACAO DA BASE DE DADOS: TAMBEM CHAMADA DE CARGA INICIAL DE BASE DE DADOS, SEMPRE QUE EXECUTAR O PROEJTO EXECUTA A OPERACAO COM A BASE DE DADOS INTANCIADA, EXISTE VARIAS FORMAS, MAS NA AULA SERA ABORDADA PELO CONFIG

CHECKLIST:
- NO SUBPACOTE CONFIG, CRIAR UMA CLASSE DE CONFIGURACAO INSTATIATION QUE IMPLEMENTE COMMANDLINERUNNER

MUITO SEMELHANTE O METODO DE SALVAR DE BD DE DOCUMENTOS COM BD RELACIONAIS, USA-SE O METODO SAVEALL TAMBEM, POREM IMPLMENTACAO MUDA UM POUCO
NESSA CLASSE DE CONFIGURACAO DEVEMOS UTLIZAR A ANOTACAO @CONFIGURATION PARA QUE O SPRING ENTENDA QUE E UMA CLASSE DE CONFIGURACAO E FAZ COM QUE A CADA VEZ QUE RODARMOS A APLICACAO, EXECUTE O QUE ESTA CONTIDO DENTRO DO METODO RequestMapping

PASSO 5 - USANDO PADRAO DTO PARA RETORNAR USUARIOS: 

DTO -> DATA TRANSFER OBJECT E UM OBJETO QUE TEM O PAPEL DE CARREGAR DADOS DAS ENTIDADES DE FORMA SIMPLES, PODENDO INCLUSIVE "PROJETAR"(CRIAR UM OBJETO MAIS SIMPLES EX UM OBJETO TEM 30 ATRIBUTOS MAS PRECISO SO DE 10, CARREGANDO APENAS O NECESSARIO) APENAS ALGUNS DADOS DE ENTIDADE ORIGINAL.
VANTAGENS:
- OTIMIZA O TRAFEGO(TRAFEGANDO MENOS DADOS)
- EVITA QUE DADOS DE INTERESSES EXCLUSIVOS DO SISTEMAS FIQUEM SENDO EXPOSTOS(POR EXEMPLOS SENHAS, DADOS DE AUDITORIA COMO A DATA DE CRIACAO E DATA DE ATUALIZACAO DO OBJETO, ETC)
- CUSTOMIZAR OS OBJETOS TRAFEGADOS CONFORME A NECESSIDADE DE CADA REQUISICAO(POR EXEMPLO PARA ALTERA UM PRODUTO VOCE PRECISA DOS DADOS A,B E C JA PARA LISTAR OS PRODUTOS EU PRECISO DOS DAODS A, B E A CATEGORIA DO PRODUTO, ETC)

CHECKLIST:
- NO SUBPACOTE DTO, CRIAR USERDTO
- EM USERRESOURCE, REFATORAR O METODO FINDALL POIS IREMOS RETORNAR UM USER DTO E NAO UMA LISTA DE USER

PASSO 6 - OBTENDO UM USUARIO POR ID:

CHECKLIST:
- NO SUBPACOTE SERVICE.EXEPTION CRIAR OBJECTNOTFOUNDEXCEPTION
- EM USERSERVICE, IMPLEMENTAR O METODO FINDBYID
- EM USERRESOURCE, IMPLEMENTAR O METODO FINDBYID(RETORNA UM DTO)
- NO SUPACOTE RESOURCES.EXCEPTION CIAR AS CLASSES:
* STANDARDERROR
* RESOURCEEXCEPTIONHANDLER -> NESSA CLASSE DEVEMOS USAR A ANOTACAO @CONTROLLERADIVCE PARA QUE O SPRINGBOOT POSSA ENTENDER QUE ESSA CLASSE E RESPONSAVEL POR TRATAR POSSIVEIS ERROS NAS REQUISICOES, DEVE-SE COLOCAR TAMBEM A ANOTACAO @EXCEPTIONHANDLE(NOME_EXECAO.CLASS) PARA INDETIFICAR Q QUANDO OCORRER UMA DETERMINADA EXECAO REALIZAR UMA DETERMINADA ACAO

PARA PASSAR OBJETOS POR PARAMETROS DA FUNCAO, OBJETOS QUE VIERAM DA REQUISCAO, DEVEMO UTILIZAR O @PATHVARIABLE ANTES DO TIPO DO PARAMETRO DA FUNCAO

PASSO 7 - INSERCAO DOS USUARIOS PELO METODO POST:

CHECKLIST:
- EM USERSERVICES, IMPLEMENTAR METODOS INSERT E FROMDTO(PEGA UM DTO E INSTANCIAR UM USUARIOS)
- EM USERRESOURCE, IMPLEMENTAR METODO INSERT

PARA INSERRIMOS O OBJETO NO BD, UTILIZAMOS O COMABDO .INSERT(OBJ)
FOI FEITO NO USERSERVICE POIS DEPENDENDO DA SITUACAO PARA INSTANCIAR UM USARIO POR EXEMPLO DEVE-SE IR NO BD, POR ISSO COLOCA NO SERVICE POIS TEM ACESSO A DADOS DO BD
OBS1: DEPENDENDO DA SITUACAO TEMOS QUE QUEBRAR UM POUCO DA DELGACAO, DEVIDO A MANUTENCAO NO FUTURO DE ACESSO A DADOS

UTILIZAMOS O METODO DE REQUISOCAO POST PARA PODER INSERIR USARIOS NO BD 
PODEMOS UTILIZAR A ANOTACAO @POSTINGMAPPING
SEMELHANTE AO DO MODELO RELACIONAL, NO METODO POST, AO RECEBER ALGUM OBJETO POR PAREMTROS, DEVEMOS COLOCAR A ANOTACAO @REQUESTBODY  

PARA RESPOSTAS DE INSERCAO, E BOM RETORNAR UMA RESPOSTA VAZIA POREM COM UM CABECALHO COM A URL DO RECURSO CRIADO, E UMA BOA PRATICA, ISSO E FEIT OATRAVES DO COMANDO ABAIXO, ONDE PEGAMOS AS INFORMACOES SOBRE O OBJETO QUE FOI REQUISITADO A INSERCAO PELO METODO POST:
URI uri = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(obj.getId()).toUri(); 
O .CREATED RETORNA O CODIGO 201 CODIGO QUE FOI CRIADO COM SUCESSO UM OBJETO

OBS1: DEVE-SE CONFERIR NO CABECALHO A URL DO USER CRIADO

PASSO 8 - DELECAO DE USUARIOS COM DELETE:

CHECKLIST:
- EM USERSERVICE, IMPLEMENTAR O METODO DELETE
- EM USERRESOURCE, IMPLEMENTAR O METODO DELETE

PODEMOS USAR O @DELETEMAPPING COM ANOTACAO DE UM DELETE
EM REQUISOCES QUE RETORNAM VOID, DEVE-SE UTILIZAR O .NOCONTENT
OBS1: PARA TRATAR EXECAO DE ID NAO ENCONTRADO, BASTA CHAMAR O FINDBYID ANTES DE EXECUTAR A DELECAO

PASSO 9 - ATUALIZACAO DE USUARIOS COM O METODO PUT:

CHECKLIST:
- EM USERSERVICE, IMPLEMENTAR OS METODOS UPDATE E UPDATEDATA
- EM USERRESOURCE IMPLEMENTAR OS MTODOS UPDATE

PARA FAZER ATAULIZACAO DE DADOS NO BD, UTILIZAMOS A REQUISCAO HTTP POST PARA ENVIAR OS DADOS E ATUALIZAR NO BD
O UPDATE DATA FOI CRIADO PARA PEGAR OS DADOS DA REQUISICAO E ATUALIZAR O OBJETO COM OS DADOS DA REQUISICAO
RETORNA NOCONTENT IGUAL O DELETE

OBS1: C(CREATE)R(READ)U(UPDATE)D(DELETE) 

PASSO 10 - DISCUTINDO DESING DO MODELO DE DOMINIO:

NOS BD RELACIONAIS, CADA LINHA DA TABELA CORRESPONDE A UMA INSTANCIA DO USUARIO, OS MESMOS SAO RELACIONADOS ATRAVES DE CHAVES EXTRANGEIRSA, QUE FAZEM REFERENCIA AQUELE OBJETO NA TABELA PARA UM DETERMINADO OBJETO EM OUTRA TABELA
EM BD ORENTADO A AGRAGADOS, TEMOS VARIOS DADOS AGREGADOS, COMO POR EXEMPLO UMA LISTA DE OUTROS OBJETOS QUE ESSE OBJETO ESTA RELACIONADO, EM BD AGREGADOS, RETORNA TODAS AS ENTIDADES, ALGUNS DADOS PODEM VIR REPETIDOS, OS DADOS JA VEM TODOS DE UMA VEZ
EM BD AGREGADOS, PODEMOS ESCOLHER SE QUEREMOS AGREGAR TUDO OU NAO, DEPENDE DO NEGOCIO, SE TIVER MUITOS DADOS NAO E MUITO VIAVEL
EM BD AGREGADOS PODEMOS TER LISTAS, REDUZINDO COMPATIBILIDADE DE IMPEDANCIA
PODEMOS LIMITAR O QUE MOSTRAR, COLOCANDO AS REFERENCIAS GERANDO A LISTA CITADA ACIMA
AO LIMITAR, CRIAMOS COLECOES SEPARADAS

SE FOREM MUITO GRANDES E RELEVANCIA PRORPIA DEVE-SE UTILIZAR REFERENCIAS
SE FOREM MUITOS SIMPLES OU NECESSIDADE DE ACESSAR TUDO FOR FREQUENTE DEVE-SE UTILIZAR TODOS ALINHADS

PASSO 11 - CRIANDO ENTITY POST COM USER ALINHADO:

CHECKLIST:
- CIRAR CLASSE POST
- CIRAR POST REPOSITORY
- INSERIR ALGUNS POSTS NA CARGA INICIAL DA BASE DE DADOS

QUANDO FAZEMOS UM RELACIONAMENTO, O DOCUMENTO RECEBE UMA COPIA DO OUTRO DOCUMENTO RELACIONADO, CAUSADA PELA ALINHACAO

PASSO 12 - PROJECAO DE DADOS DO AUTOR USERDTO:

CHECKLIST:
- CRIAR AUTHORDTO
- REFATORAR POST
- REFATORAR A CARGA INICIAL DO BANCO DE DADOS
OBS1: IMPORTANTE !! AGORA E PRECISO PERSISTIR OS OBJETOS USERS ANTES DE RELACIONAR -> DEVE-SE INSTANCIAR O DTO, DEVE-SE INSTANCIAR OS USUARIOS PRIMEIROS PARA QUE OS MESMOS SEJAM INSTANCIADOS NO DB PARA QUE SEJAM RECUPERADOS ANTES DE CIRAMOS OS OBJETOS NOS QUAIS OS OUTROS OBJETOS SAO RELACIONADOS

PROJECAO COM DADOS DTO E IMPORTANTE PARA PROJETAR OS DADOS DE UMA DETERMINADA ENTIDADE
COM ISSO, UTILIZAMOS O METODO DE ALINHAMENTO, ONDE TEMOS UM ALINHAMENTO NO BD A UMA CLASSE DTO PARA INSTANCIAR UMA CLASSE COMPOSTA, ONDE TEMOS UMA COPIA DOS DADOS E SALVO NAQUELE AGREGADO

PASSO 13 - REFERENCIANDO OS POST DO USUARIO: 

NESSA PARTE, IREMOS AGREGAR OS POST COM FORMA DE REFERENCIA E NAO ALINHADOS, E UMA OUTRA COLECAO PARA ESSE OBJETOS REFERENCIADOS

CHECKLIST:
- EM USER CIRA O ATRIBUTO "POSTS", USANDO @DBREF
* SUGESTAO: INCLUIR O PARAMENTRO (LAZY=TRUE) -> PARA QUE FACA O CARREGAMENTO PREGUICOSO, APENAS QUANDO NECESSARIO
- REFATORAR A CARGA INICIAL DO BANCO, INCLUINDO AS ASSOCIACOES DOS POSTS

OBS1: EM SPRINGDATA PARA FALAR QUE UM ATRIBUTO REFERENCIA OUTRO COLOECAO DO MONGO DB E SO USAR O @DBREF 

PASSO 14 - ENDPOIT PARA RETORNAR OS POSTS DE UM USUARIO:

CHECKLIST:
- EM USERSERVICE, CRIAR O METODO PARA RETORNAR OS POST DE UM DADO USUARIO

PASSO 15 - OBTENDO POST POR ID:

CHECKLIST:
- CRIAR POSTSERVICE COM METODO FINDBYID
- CRIAR POSTRESOURCE COM O METODO FINDBYID

PASSO 16 - ACRESCENTANDO COMENTARIOS AOS POSTS:

CHECKLIST:
- CRIAR COMMENTDTO
- EM POSTS, INCLUIR UMA LISTA DE COMMENTDTO
- REFATORAR A CARGA INICIAL DO BD, INCLUINDO ALGUNS COMENTARIOS NOS POSTS

PASSO 17 - CONSULTA SIMPLES COM QUERY METHODS:

OS QUERY METHODS SAO METODOS ESPECIAS QUE O SPRING DATA OFERECE PARA AUTOMATICAMENTE AS CONSULTAS PARA GENTE
TEMOS INUMERAS POSSIBILIDADES DE VERIFICACAO DA CONSULTA, COMO AFTER QUE PEGA OS DADOS ACIMA DE UM DETERMINADO VALOR

CONSULTA: "BUSCAR POST CONTENDO UM DADO STRING NO TITULO" -> UTILIZA O METODO CONTAINING PARA VERIRICAR SE UMA STRING CONTEM UMA DETERMINADA STIRING

CHECKLIST:
- EM POSTREPOSITORY CRIAR O METODO DE BUSCAR -> PARA QUE O SPRINGDATA CONSIGA REALIZAR A CONSUTA ATRAVES DO MONGO REPOSITORY
- EM POSTSERVICE, CRIAR O METODO DE BUSCAR
- NO SUBPACOTE RESOURCES.UTIL CRIAR A CLASSE UTILITARIA URL COM UM METODO PARA DECODIFICAR PARAMETROS DE URL
- EM POSTRESOURCE, IMPLMENTAR O ENDPOINT

OBS1: DEVE-SE IMPLEMENTAR O METODO NA INTERFACE REPOSITORY POIS NELA ESTA EXTENDIDA DO REPOSITORY DO DB SPRINGDATA QUE CONTEM ALGUMAS ACOES JA SALVAS FAZEND COM QUE UTILIZAMOS A CHAMADA DEMETODOS NAO NECESSARIO IMPLEMENTAR O CODIGO, POIS O PROPRIO STRING JA FAZ O CODIGO SQL, BASTA CHAMAR O METODO
OBS2: SEMPRE DEVE-SE ACOMPANHAR O MODELO DE ESCRITA FINDBYNOME_CAMPOCONDICAO
OBS3: DEVEMOS DECODIFICAR OS PARAMETROS URL POIS O PARAMETRO E RESPEITADO PELO PROTOCOLO HTTP NOME_VAR?=VAL_VAR, PODE TER CARACTERS ESPECIAIS DEVIDO A ESPACO OU ACENTOS, POR ISSO O JAVA POSSUI UMA FUNCAO CAMADA ENCODEURICOMPNET() QUE ENCODA O VALOR, PARA DECODIFICAR, DEVEMOS CRIAR UM METODO PARA DECODIFICAR A URL, CHAMANDO APENAS A FUNCAO URLDECODER.DECODE E O 2 QUE TEM 2 PARAMETSO O TEXTO E O PADRAO, POIS DEVEMOS ESPECIFICAR O PADRAO QUE ESTAMOS DECODIFICANDO 
OBS4: DEVEMOS SEMPRE IMPLEMENTAR ESSA CLASSE QUANDO PEGAMOS VALORES DA URL, DEVEMOS SEMPRE TRATAR UMA EXECAO, CASO NAO ENCONTRE NADA RETONRA UM CAMPO VAZIO

DEVEMOS UTILIZAR A ANOTACAO @REQUESTPARAM QUANDO VAMOS PEGAR UM VALOR VINDO DA URL, DEVEMOS DEFINIR OVALUE O VALOR DE VALUE, ONDE O NOME DE VALUE, VAI SE O QUE APARECE APOS O ? E O VALOR DO NOME DA ROTA
PARA FAZER COM QUE AS PESQUISAS NAO DEEM ERRO CASO DIGITEM TUDO MINUSCULO OU MAISUCULO, DEVEMOS UTILIZAR O IGNORECASE NO REPOSITORIO NO MOMENTO DA BUSCA

PASSO 18 - CONSULTA SIMPLES COM @QUERRY:

NESSA ETAPA IREMOS FAZER A CONSULTA ANTERIOR COM A ANOTACAO @QUERY, ESSA ANOTACAO PERMITE A ENTRADA DA CONSULTA DO MONGO DB EM JSON, ESSAS CONSULTAS SERAO SEMPRE DA MESMA FORMA POIS AS CONSULTAS SAO DO PRORIO BD, CADA BD TEM SEU JEITO DO MONGO E A SEGUINTE:
{<NOME_CAMPO>: { $REGEX: /PATTERN/, $OPTIONS: '<OPTIONS>'}}
OBS1: OPTIONS SAO OPICIONAIS

REGEX E UTILIZADO PARA FAZRE AS BUSCAS

CONSULTA: "BUSCAR POSTS CONTENDO UM DADO STRING NO TITULO"

CHECKLIST:
- EM POSTREPOSITORY FAZER A IMPLEMENTACAO ALTERNATIVA DA CONSULTA
- EM POSTSERVICE ATUALIZAR A CHAMDADA DA CONSULTA

COMO NO METHODO QUERY, QUANTO VAMOS UTILIZAR A ANOTACAO @QUERRY DEVEMOS LISTALA NA INTERFACE, PARA QUE AS CLASSES QUE EXTENDEM AQUELA INTERFACE SEJAM OBRIGADAS A CUMPRIR O CONTRATO
DENTRO NA PROPRIA INTERFACE, AO DEFINIR O NOME DA FUNCAO E SEUS PARAMENTROS, DEVE-SE COLOCAR A ANOTACAO @QUERY(CODIGO_QUERY_SQL)

NA FRENTE DO REGEX COLOCA O ?0 POIS QUREMOS O PRIMEIRO PARAMETRO DPS DA INTERROGACAO, SE TIVER MAIS ENTERROGACAO ?N ONDE N REPRESENTA A POSICA DO PARAMETRO

PASSO 19 - CONSULTA COM VARIOS CRITERIOS:

COMO PODEMOS UTILIZAR A ANOTACAO @QUERY PARA REALIZAR A MAO NOSSAS CONSULTAS, PODEMOS CRIA UMA BUSCA MAIS COMPLEXA ATRAVES DOS COMANDOS DE BUSCA DO BD
PARA REALIZAR BUSA COMPLEXAS, UTILIZA OS ATRIBUTOS $ DO MOONGODB
OBS1: QUANDO E OBJETO AGREDOS, NAO BASTA APENA CHAMA A LISTA, DEVEMOS FAZER OUTRO TRATAMENTO, QUE E IR NA VARIAVEL EM ESPECIFICA QUE DEVE-SER TRATADA COMO POR EXEMPLO ATRIBUTO_ASSOCIADO_DOC.ATRIBUTO_DOC_ASSOCIADO
OBS2: COMPARACAO EM INTERVALO DE DATA, DEVE COMPARA ATE O FINAL DE UM DIA, DEVE-SE ACRECESNTAR UM DIA NA DATA COM O COMANDO (maxDate.getTime() + 24 * 60 * 60 * 1000); 

CONSULTA: "BUSCAR POSTS CONTENDO UM DADO STRING QUALQUER LUGAR(TITULO, CORPO OU COMENTARIO) E EM UM DADO INTERVALO DE DATAS"

CHECKLIST:
- EM POSTREPOSITORY CIRAR O METODO CONSULTA
- EM POSTSERVICE CRIAR O METODO CONSULTA
- NA CLASSE UTILITARIO URL, CRIA METODOS PARA TRATAR DATAS RECEBIDAS
- EM POSTRESOURCE IMPLMENTAR O END POINT
